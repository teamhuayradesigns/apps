<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colored Noise Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.71/build/Tone.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* Dark background */
            color: #e2e8f0; /* Light text */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            box-sizing: border-box;
        }
        .container {
            background-color: #2d3748; /* Darker gray for container */
            border-radius: 1.5rem; /* More rounded corners */
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5); /* Stronger shadow */
            padding: 2rem;
            max-width: 600px;
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }
        .noise-button {
            @apply flex-1 px-6 py-3 rounded-xl font-semibold transition-all duration-200 ease-in-out text-lg shadow-md;
            background: linear-gradient(145deg, #4a5568, #2d3748); /* Gradient for buttons */
            color: #cbd5e0;
            border: none;
            cursor: pointer;
        }
        .noise-button:hover {
            background: linear-gradient(145deg, #5a6578, #3d4758); /* Darker gradient on hover */
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
        }
        .noise-button.active {
            background: linear-gradient(145deg, #6b7280, #4b5563); /* Active state */
            color: #a0aec0;
            transform: translateY(0);
            box-shadow: inset 0 3px 5px rgba(0, 0, 0, 0.5);
        }
        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 0.5rem;
            background: #4a5568; /* Slider track color */
            outline: none;
            border-radius: 9999px;
            cursor: pointer;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.4);
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 1.5rem;
            height: 1.5rem;
            background: #63b3ed; /* Thumb color (blue) */
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: background 0.2s ease-in-out;
        }
        input[type="range"]::-moz-range-thumb {
            width: 1.5rem;
            height: 1.5rem;
            background: #63b3ed;
            border-radius: 50%;
            cursor: grab;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
            transition: background 0.2s ease-in-out;
        }
        input[type="range"]::-webkit-slider-thumb:hover {
            background: #4299e1; /* Darker blue on hover */
        }
        input[type="range"]::-moz-range-thumb:hover {
            background: #4299e1;
        }

        .stop-button {
            @apply px-6 py-3 rounded-xl font-semibold transition-all duration-200 ease-in-out text-lg shadow-md;
            background: linear-gradient(145deg, #e53e3e, #c53030); /* Red gradient */
            color: #fed7d7;
            border: none;
            cursor: pointer;
            width: 100%;
        }
        .stop-button:hover {
            background: linear-gradient(145deg, #f56565, #e05252); /* Lighter red on hover */
            transform: translateY(-2px);
            box-shadow: 0 5px 10px rgba(0, 0, 0, 0.4);
        }
        .noise-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr); /* 2 columns on small screens */
            gap: 1rem;
        }
        @media (min-width: 640px) { /* sm breakpoint */
            .noise-grid {
                grid-template-columns: repeat(3, 1fr); /* 3 columns on larger screens */
            }
        }
        .current-noise-display {
            @apply text-center text-xl font-bold mt-2 mb-4;
            color: #90cdf4; /* Light blue */
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-3xl sm:text-4xl font-bold text-center mb-6 text-blue-300">Colored Noise Generator</h1>

        <div class="current-noise-display" id="currentNoiseDisplay">No noise playing</div>

        <div class="noise-grid">
            <button class="noise-button" data-noise-type="white">White Noise</button>
            <button class="noise-button" data-noise-type="pink">Pink Noise</button>
            <button class="noise-button" data-noise-type="brown">Brown Noise</button>
            <button class="noise-button" data-noise-type="blue">Blue Noise</button>
            <button class="noise-button" data-noise-type="violet">Violet Noise</button>
            <button class="noise-button" data-noise-type="green">Green Noise</button>
            <button class="noise-button" data-noise-type="gray">Gray Noise</button>
            <button class="noise-button" data-noise-type="black">Black Noise</button>
        </div>

        <div class="volume-control mt-6">
            <label for="volumeSlider" class="block text-center text-lg font-medium mb-2">Volume</label>
            <input type="range" id="volumeSlider" min="-40" max="0" value="-10" step="1">
        </div>

        <button class="stop-button mt-4" id="stopButton">Stop All Noise</button>
    </div>

    <script>
        // Tone.js requires starting the audio context on a user gesture.
        // This variable will hold the active noise generator.
        let activeNoise = null;
        let masterVolume = new Tone.Volume().toDestination();
        let blackNoiseInterval = null;
        let blackNoiseOscillator = null;

        // Set initial volume from slider
        const volumeSlider = document.getElementById('volumeSlider');
        masterVolume.volume.value = parseFloat(volumeSlider.value);

        // Update volume on slider change
        volumeSlider.addEventListener('input', (e) => {
            masterVolume.volume.value = parseFloat(e.target.value);
        });

        // Function to stop all playing noise
        function stopAllNoise() {
            if (activeNoise) {
                activeNoise.stop();
                activeNoise.dispose(); // Clean up resources
                activeNoise = null;
            }
            // Stop black noise specific components
            if (blackNoiseInterval) {
                clearInterval(blackNoiseInterval);
                blackNoiseInterval = null;
            }
            if (blackNoiseOscillator) {
                blackNoiseOscillator.stop();
                blackNoiseOscillator.dispose();
                blackNoiseOscillator = null;
            }
            document.getElementById('currentNoiseDisplay').textContent = 'No noise playing';
            // Deactivate all buttons
            document.querySelectorAll('.noise-button').forEach(button => {
                button.classList.remove('active');
            });
        }

        // Function to play a specific noise type
        async function playNoise(type) {
            // First, ensure audio context is started
            await Tone.start();
            stopAllNoise(); // Stop any currently playing noise

            document.getElementById('currentNoiseDisplay').textContent = `${type.charAt(0).toUpperCase() + type.slice(1)} Noise playing...`;

            switch (type) {
                case 'white':
                    activeNoise = new Tone.Noise('white').connect(masterVolume);
                    activeNoise.start();
                    break;
                case 'pink':
                    activeNoise = new Tone.Noise('pink').connect(masterVolume);
                    activeNoise.start();
                    break;
                case 'brown':
                    activeNoise = new Tone.Noise('brown').connect(masterVolume);
                    activeNoise.start();
                    break;
                case 'blue':
                    // Blue noise: power increases 3dB per octave.
                    // This can be approximated by a high-shelf filter or a cascade of high-pass filters.
                    // A simple high-pass with some resonance can give a "hissy" quality.
                    activeNoise = new Tone.Noise('white');
                    const blueFilter = new Tone.Filter(2000, 'highpass', -12).connect(masterVolume); // High-pass at 2kHz, 12dB/octave slope
                    activeNoise.connect(blueFilter);
                    activeNoise.start();
                    break;
                case 'violet':
                    // Violet noise: power increases 6dB per octave.
                    // Stronger high-pass filter.
                    activeNoise = new Tone.Noise('white');
                    const violetFilter = new Tone.Filter(5000, 'highpass', -24).connect(masterVolume); // High-pass at 5kHz, 24dB/octave slope
                    activeNoise.connect(violetFilter);
                    activeNoise.start();
                    break;
                case 'green':
                    // Green noise: mid-range emphasis, centered around 500 Hz.
                    activeNoise = new Tone.Noise('white');
                    const greenFilter = new Tone.Filter(500, 'bandpass', -12).connect(masterVolume); // Band-pass at 500Hz, 12dB/octave slope
                    greenFilter.Q.value = 2; // Q factor for bandwidth
                    activeNoise.connect(greenFilter);
                    activeNoise.start();
                    break;
                case 'gray':
                    // Gray noise: perceptually balanced loudness.
                    // This is complex as it depends on individual ear response.
                    // A rough approximation can involve shaping white noise to follow an inverse equal-loudness contour.
                    // For simplicity and common use, a "smoothed" white noise might be used,
                    // or for this demo, we'll try to emulate a 'perceptually flat' sound using a custom filter.
                    // This is a simplification; true gray noise often requires individual calibration.
                    activeNoise = new Tone.Noise('white');
                    const grayFilter = new Tone.EQ3(0, 0, 0).connect(masterVolume); // Simple EQ for shaping
                    grayFilter.low.value = -10; // Reduce low end
                    grayFilter.high.value = -10; // Reduce high end
                    // This is a very rough approximation. For true gray noise, a more complex filter
                    // that inverts the human hearing curve (e.g., A-weighting inverse) is needed.
                    activeNoise.connect(grayFilter);
                    activeNoise.start();
                    break;
                case 'black':
                    // Black noise: silence with occasional random spikes.
                    // This will not be a continuous Tone.Noise object.
                    // Instead, we'll periodically trigger short bursts.
                    blackNoiseInterval = setInterval(() => {
                        // Create a temporary oscillator for the spike
                        blackNoiseOscillator = new Tone.Noise('white').connect(masterVolume);
                        // Random duration and volume for the spike
                        const duration = Math.random() * 0.1 + 0.05; // 50ms to 150ms
                        const volume = Math.random() * 5 - 25; // -25dB to -20dB
                        blackNoiseOscillator.volume.value = volume;
                        blackNoiseOscillator.start().stop('+' + duration); // Play for a short duration
                        // Dispose after it stops playing
                        Tone.Transport.scheduleOnce(() => {
                            if (blackNoiseOscillator) {
                                blackNoiseOscillator.dispose();
                                blackNoiseOscillator = null;
                            }
                        }, Tone.Transport.now() + duration + 0.1); // Ensure it's disposed after it stops
                    }, Math.random() * 1000 + 500); // Interval between 0.5s and 1.5s
                    // No continuous activeNoise for black noise, but the interval and oscillator are managed.
                    break;
                default:
                    console.error("Unknown noise type:", type);
                    return;
            }
        }

        // Add event listeners to all noise buttons
        document.querySelectorAll('.noise-button').forEach(button => {
            button.addEventListener('click', (e) => {
                const noiseType = e.target.dataset.noiseType;
                // Remove active class from all buttons
                document.querySelectorAll('.noise-button').forEach(btn => btn.classList.remove('active'));
                // Add active class to the clicked button
                e.target.classList.add('active');
                playNoise(noiseType);
            });
        });

        // Add event listener to the stop button
        document.getElementById('stopButton').addEventListener('click', stopAllNoise);

    </script>
</body>
</html>
