<!-- Test comment to verify mode switching functionality -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Master Generator</title>

    <!-- PWA Meta Tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
    <meta name="theme-color" content="#1e293b" media="(prefers-color-scheme: dark)">
    <meta name="color-scheme" content="light dark">
    <link rel="manifest" href="data:application/manifest+json,{
        "name": "Generator",
        "short_name": "ToneGen",
        "start_url": ".",
        "display": "standalone",
        "background_color": "#f1f5f9",
        "theme_color": "#ffffff",
        "description": "A tone, noise, and frequency sweep generator PWA.",
        "icons": [
            { "src": "https://placehold.co/192x192/000000/FFFFFF?text=🎵", "sizes": "192x192", "type": "image/png" },
            { "src": "https://placehold.co/512x512/000000/FFFFFF?text=🎵", "sizes": "512x512", "type": "image/png" }
        ]
    }">

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/flac-builds@0.2.0/dist/flac.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior-y: contain;
        }
        input:disabled, select:disabled {
             opacity: 0.5;
            cursor: not-allowed;
        }
        /* Use monospaced numbers to prevent layout shift */
        .tabular-nums {
            font-variant-numeric: tabular-nums;
        }
        
        /* Polarity checker styles */
        #polarity-result .in-phase {
            color: #22c55e; /* green-500 */
        }
        #polarity-result .out-of-phase {
            color: #ef4444; /* red-500 */
        }
        
        /* Hardware Panel Styles */
        .polarity-hardware-panel {
            background: linear-gradient(145deg, #6b7280, #4b5563, #374151);
            border: 1px solid #9ca3af;
            box-shadow: inset 0 1px 3px rgba(255,255,255,0.1), 0 4px 12px rgba(0,0,0,0.3);
        }
        
        /* LED indicator styles */
        .led-on-green {
            background: radial-gradient(circle, #22c55e 0%, #16a34a 70%);
            box-shadow: 0 0 15px #22c55e, 0 0 25px #22c55e;
            border-color: #22c55e;
        }
        
        .led-on-red {
            background: radial-gradient(circle, #ef4444 0%, #dc2626 70%);
            box-shadow: 0 0 15px #ef4444, 0 0 25px #ef4444;
            border-color: #ef4444;
            animation: led-pulse-red 1s ease-in-out infinite alternate;
        }
        
        .led-on-yellow {
            background: radial-gradient(circle, #fbbf24 0%, #f59e0b 70%);
            box-shadow: 0 0 15px #fbbf24, 0 0 25px #fbbf24;
            border-color: #fbbf24;
        }
        
        .led-on-red-solid {
            background: radial-gradient(circle, #ef4444 0%, #dc2626 70%);
            box-shadow: 0 0 15px #ef4444, 0 0 25px #ef4444;
            border-color: #ef4444;
        }
        
        .led-on-red-pulse {
            background: radial-gradient(circle, #ef4444 0%, #dc2626 70%);
            box-shadow: 0 0 15px #ef4444, 0 0 25px #ef4444;
            border-color: #ef4444;
            animation: led-pulse-red 1s ease-in-out infinite alternate;
        }
        
        @keyframes led-pulse-red {
            0% {
                box-shadow: 0 0 8px #ef4444, 0 0 4px #dc2626, inset 0 1px 1px rgba(255, 255, 255, 0.3);
            }
            100% {
                box-shadow: 0 0 12px #ef4444, 0 0 8px #dc2626, 0 0 4px #fca5a5, inset 0 1px 1px rgba(255, 255, 255, 0.3);
            }
        }
        
        @keyframes led-pulse-yellow {
            0% {
                box-shadow: 0 0 8px #fbbf24, 0 0 4px #f59e0b, inset 0 1px 1px rgba(255, 255, 255, 0.3);
            }
            100% {
                box-shadow: 0 0 12px #fbbf24, 0 0 8px #f59e0b, 0 0 4px #fde68a, inset 0 1px 1px rgba(255, 255, 255, 0.3);
            }
        }
        
        /* Large Knob Styles */
        .knob-large {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #9ca3af, #6b7280, #4b5563);
            border: 3px solid #d1d5db;
            box-shadow: inset 0 3px 6px rgba(0,0,0,0.4), inset 0 -2px 4px rgba(255,255,255,0.1), 0 6px 12px rgba(0,0,0,0.3);
            position: relative;
            transition: all 0.1s ease;
        }
        
        .knob-large::before {
            content: '';
            position: absolute;
            top: 4px;
            left: 4px;
            right: 4px;
            bottom: 4px;
            border-radius: 50%;
            background: linear-gradient(145deg, #374151, #1f2937);
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.1);
        }
        
        .knob-large:hover {
            box-shadow: inset 0 3px 6px rgba(0,0,0,0.5), inset 0 -2px 4px rgba(255,255,255,0.15), 0 8px 16px rgba(0,0,0,0.4);
        }
        
        .knob-inner {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #4b5563, #374151, #1f2937);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #6b7280;
            z-index: 2;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3);
        }
        
        .knob-indicator {
            width: 4px;
            height: 22px;
            background: linear-gradient(180deg, #60a5fa, #3b82f6);
            position: absolute;
            top: 4px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 2px;
            box-shadow: 0 0 12px #60a5fa, inset 0 1px 2px rgba(255,255,255,0.3);
            z-index: 3;
        }
        
        /* Small Knob Styles */
        .knob-small {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #9ca3af, #6b7280, #4b5563);
            border: 2px solid #d1d5db;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.4), inset 0 -1px 2px rgba(255,255,255,0.1), 0 4px 8px rgba(0,0,0,0.3);
            position: relative;
            transition: all 0.1s ease;
        }
        
        .knob-small::before {
            content: '';
            position: absolute;
            top: 3px;
            left: 3px;
            right: 3px;
            bottom: 3px;
            border-radius: 50%;
            background: linear-gradient(145deg, #374151, #1f2937);
            box-shadow: inset 0 1px 2px rgba(255,255,255,0.1);
        }
        
        .knob-small:hover {
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.5), inset 0 -1px 2px rgba(255,255,255,0.15), 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .knob-inner-small {
            width: 35px;
            height: 35px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #4b5563, #374151, #1f2937);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border: 1px solid #6b7280;
            z-index: 2;
            box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .knob-indicator-small {
            width: 3px;
            height: 14px;
            background: linear-gradient(180deg, #fbbf24, #f59e0b);
            position: absolute;
            top: 3px;
            left: 50%;
            transform: translateX(-50%);
            border-radius: 1.5px;
            box-shadow: 0 0 8px #fbbf24, inset 0 1px 1px rgba(255,255,255,0.3);
            z-index: 3;
        }
        
        /* Power Button Styles */
        .power-button {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: linear-gradient(145deg, #6b7280, #4b5563);
            border: 2px solid #9ca3af;
            color: #d1d5db;
            transition: all 0.2s ease;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2), 0 4px 8px rgba(0,0,0,0.3);
            position: relative;
            overflow: hidden;
        }
        
        .power-button::before {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            right: 2px;
            bottom: 2px;
            border-radius: 50%;
            background: linear-gradient(145deg, #9ca3af, #6b7280);
            z-index: 1;
        }
        
        .power-button svg {
            position: relative;
            z-index: 2;
        }
        
        .power-button:hover {
            color: #60a5fa;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 6px 12px rgba(0,0,0,0.4);
            transform: translateY(-1px);
        }
        
        .power-button:hover::before {
            background: linear-gradient(145deg, #a5b4fc, #6b7280);
        }
        
        .power-button.active {
            color: #22c55e;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 0 20px rgba(34, 197, 94, 0.4), 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .power-button.active::before {
            background: linear-gradient(145deg, #86efac, #22c55e);
        }
        
        /* Beta text animation */
        #beta-text {
            font-size: 0.6rem;
            font-weight: 600;
            animation: colorChange 3s infinite;
            margin-top: 2px;
        }
        
        @keyframes colorChange {
            0% { color: #ef4444; }
            16.66% { color: #f97316; }
            33.33% { color: #eab308; }
            50% { color: #22c55e; }
            66.66% { color: #3b82f6; }
            83.33% { color: #8b5cf6; }
            100% { color: #ef4444; }
        }
        
        /* Custom Slider Styles */
        .custom-slider {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            background: #4a5568;
            border-radius: 3px;
            outline: none;
            cursor: pointer;
        }
        
        .custom-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f6ad55;
            cursor: pointer;
            border: 2px solid #ed8936;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .custom-slider::-webkit-slider-thumb:hover {
            background: #ed8936;
            transform: scale(1.1);
            transition: all 0.2s ease;
        }
        
        .custom-slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f6ad55;
            cursor: pointer;
            border: 2px solid #ed8936;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .custom-slider::-moz-range-track {
            height: 6px;
            background: #4a5568;
            border-radius: 3px;
        }
        
        .custom-slider::-ms-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #f6ad55;
            cursor: pointer;
            border: 2px solid #ed8936;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .custom-slider::-ms-track {
            height: 6px;
            background: #4a5568;
            border-radius: 3px;
            border: none;
            color: transparent;
        }
        
        /* Toggle Switch Styles */
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 80px;
            height: 40px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(145deg, #6b7280, #4b5563);
            border: 2px solid #9ca3af;
            border-radius: 20px;
            transition: all 0.3s ease;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2), 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 28px;
            width: 28px;
            left: 4px;
            top: 4px;
            background: linear-gradient(145deg, #d1d5db, #9ca3af);
            border-radius: 50%;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.3);
        }
        
        .toggle-switch input:checked + .toggle-slider {
            background: linear-gradient(145deg, #22c55e, #16a34a);
            border-color: #22c55e;
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2), 0 0 15px rgba(34, 197, 94, 0.4), 0 4px 8px rgba(0,0,0,0.3);
        }
        
        .toggle-switch input:checked + .toggle-slider:before {
            transform: translateX(40px);
            background: linear-gradient(145deg, #f0fdf4, #dcfce7);
            box-shadow: 0 2px 4px rgba(0,0,0,0.3), inset 0 1px 2px rgba(255,255,255,0.5);
        }
        
        .toggle-switch:hover .toggle-slider {
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 6px 12px rgba(0,0,0,0.4);
        }
        
        .toggle-switch input:checked:hover + .toggle-slider {
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.3), 0 0 20px rgba(34, 197, 94, 0.6), 0 6px 12px rgba(0,0,0,0.4);
        }
    </style>
</head>
<body class="bg-slate-100 dark:bg-slate-900">

    <!-- Main container for the PWA -->
    <div id="main-app-container" class="w-full h-screen flex flex-col p-4 sm:h-auto sm:max-w-md sm:mx-auto sm:my-8 sm:rounded-2xl sm:shadow-lg sm:p-6 bg-white dark:bg-slate-800 relative">
        
        <!-- Fixed Logs Button -->
        <button id="changelog-btn" class="absolute top-14 left-6 flex items-center space-x-2 font-semibold px-2 py-0.5 rounded-full text-xs bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600 z-10">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-card-list" viewBox="0 0 16 16">
                <path d="M14.5 3a.5.5 0 0 1 .5.5v9a.5.5 0 0 1-.5.5h-13a.5.5 0 0 1-.5-.5v-9a.5.5 0 0 1 .5-.5h13zm-13-1A1.5 1.5 0 0 0 0 3.5v9A1.5 1.5 0 0 0 1.5 14h13a1.5 1.5 0 0 0 1.5-1.5v-9A1.5 1.5 0 0 0 14.5 2h-13z"/>
                <path d="M5 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 5 8zm0-2.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm0 5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7a.5.5 0 0 1-.5-.5zm-1-5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0zM4 8a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0zm0 2.5a.5.5 0 1 1-1 0 .5.5 0 0 1 1 0z"/>
            </svg>
            <span>Logs</span>
        </button>
        
        <header class="text-center mb-6 flex-shrink-0 relative">
            <div id="version-display" class="absolute top-0 left-0 text-xs text-gray-400 dark:text-gray-500 -mt-2">v0.9.6.7</div>
            <div id="beta-text" class="absolute top-1 left-0 ml-3">[beta]</div>
            <h1 id="app-title" class="text-3xl font-bold text-gray-800 dark:text-gray-100 -mt-4 cursor-pointer select-none">Master Generator</h1>
            <p id="wavelength-display" class="text-sm text-gray-500 dark:text-gray-400 mt-5 tabular-nums"></p>
            <button id="view-toggle-btn" class="absolute top-8 right-0 flex items-center space-x-2 font-semibold px-2 py-0.5 rounded-full text-xs bg-gray-100 dark:bg-slate-700 hover:bg-gray-200 dark:hover:bg-slate-600">
                <span class="text-gray-600 dark:text-gray-300">Screens</span>
                <div class="p-1 text-gray-500 dark:text-gray-400 rounded-full">
                    <svg id="icon-number" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi" viewBox="0 0 20 20">
                        <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="10px" font-weight="bold">Hz</text>
                    </svg>
                    <svg id="icon-spectrogram" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-reception-4 hidden" viewBox="0 0 16 16">
                        <path d="M0 11.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2zM4 9.5a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-4zm4 2a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-2zm4-7a.5.5 0 0 1 .5-.5h2a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-.5.5h-2a.5.5 0 0 1-.5-.5v-11z"/>
                    </svg>
                     <svg id="icon-waveform" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-soundwave hidden" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M8.5 2a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-1 0v-11a.5.5 0 0 1 .5-.5zm-2 2a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zm4 0a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-1 0v-7a.5.5 0 0 1 .5-.5zm-6 1.5a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 1 .5-.5zm8 0a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 1 .5-.5zm-10 1a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5zm12 0a.5.5 0 0 1 .5.5v2a.5.5 0 0 1-1 0v-2a.5.5 0 0 1 .5-.5z"/>
                    </svg>
                    <svg id="icon-fft" xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" class="bi bi-graph-up hidden" viewBox="0 0 16 16">
                        <path fill-rule="evenodd" d="M0 0h1v15h15v1H0V0zm10 3.5a.5.5 0 0 1 .5-.5h4a.5.5 0 0 1 .5.5v4a.5.5 0 0 1-1 0V4.9l-3.613 4.417a.5.5 0 0 1-.74.037L7.06 6.767l-3.656 5.027a.5.5 0 0 1-.808-.588l4-5.5a.5.5 0 0 1 .758-.06l2.609 2.61L13.445 4H10.5a.5.5 0 0 1-.5-.5z"/>
                    </svg>
                </div>
            </button>
            <button id="menu-btn" class="absolute top-0 right-0 p-2 -mt-4">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>
            </button>
        </header>

        <div id="tone-generator-screen">
            <main class="sm:flex-grow-0 space-y-4">
                
                <!-- Frequency Display -->
                <div class="flex justify-center items-center h-24 bg-black rounded-lg">
                    <div id="frequency-value-wrapper" class="p-2 text-center w-auto cursor-pointer">
                        <div id="frequency-text-display">
                            <span id="frequency-value" class="text-4xl font-bold tabular-nums">30</span>
                            <span id="frequency-unit" class="text-md ml-3">Hz</span>
                        </div>
                        <input type="number" id="frequency-main-input" class="hidden text-4xl font-bold tabular-nums bg-transparent text-white text-center w-48 focus:outline-none">
                    </div>
                    <canvas id="visualizer-canvas" class="w-full h-full rounded-lg hidden"></canvas>
                </div>


            <!-- Sound Type Selector -->
            <div class="flex items-end justify-between" style="margin-top: 2rem;">
                <div class="flex items-end space-x-2 flex-grow">
                    <div style="width: calc(100% - 8rem);">
                        <div class="flex items-center space-x-2 mb-2">
                            <label for="sound-type-select" class="font-semibold text-gray-700 dark:text-gray-300 text-xs">Tones</label>
                        </div>
                        <select id="sound-type-select" class="w-full p-2 text-sm border rounded-lg dark:border-gray-600 dark:text-gray-300 bg-gray-50 dark:bg-slate-700 focus:ring-blue-500 focus:border-blue-500">
                            <option value="sine">Sine</option>
                            <option value="square">Square</option>
                            <option value="sawtooth">Sawtooth</option>
                            <option value="triangle">Triangle</option>
                            <option value="sweep">Sweep</option>
                            <option value="white">White Noise</option>
                            <option value="pink">Pink Noise</option>
                            <option value="brown">Brown Noise</option>
                            <option value="blue">Blue Noise</option>
                            <option value="violet">Violet Noise</option>
                            <option value="gray">Gray Noise</option>
                            <option value="warble">Warble Tone</option>
                            <option value="imd">IMD Test</option>
                        </select>
                    </div>
                    <div class="flex flex-col items-center">
                        <div class="mb-2" style="height: 20px;"></div>
                        <button id="tones-info-btn" class="w-8 p-2 text-sm border rounded-lg dark:border-gray-600 dark:text-gray-300 bg-gray-50 dark:bg-slate-700 hover:bg-gray-100 dark:hover:bg-slate-600 focus:ring-blue-500 focus:border-blue-500 text-blue-600 dark:text-blue-400 font-bold flex items-center justify-center transition-colors" title="Show Tones & Sounds Information">
                            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" fill="currentColor" viewBox="0 0 16 16">
                                <circle cx="8" cy="8" r="7" stroke="currentColor" stroke-width="1" fill="none"/>
                                <circle cx="8" cy="5.5" r="1" fill="currentColor"/>
                                <path d="M8 7v4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                            </svg>
                        </button>
                    </div>
                    <div style="width: 120px; margin-right: 0.5rem;">
                        <label for="preset-select" class="font-semibold text-gray-700 dark:text-gray-300 mb-2 block text-xs">Presets</label>
                        <select id="preset-select" class="w-full p-2 text-sm border rounded-lg dark:border-gray-600 dark:text-gray-300 bg-gray-50 dark:bg-slate-700 focus:ring-blue-500 focus:border-blue-500">
                            <option value="30">30 Hz</option>
                            <option value="100">100 Hz</option>
                            <option value="1000">1 kHz</option>
                            <option value="261.63">C4</option>
                            <option value="277.18">C#4/Db4</option>
                            <option value="293.66">D4</option>
                            <option value="311.13">D#4/Eb4</option>
                            <option value="329.63">E4</option>
                            <option value="349.23">F4</option>
                            <option value="369.99">F#4/Gb4</option>
                            <option value="392.00">G4</option>
                            <option value="415.30">G#4/Ab4</option>
                            <option value="440">A4</option>
                            <option value="466.16">A#4/Bb4</option>
                            <option value="493.88">B4</option>
                        </select>
                    </div>
                </div>
                <div class="flex items-start space-x-2">
                    <div style="width: 100px; margin-top: 0;">
                        <label for="frequency-output" class="font-semibold text-gray-700 dark:text-gray-300 mb-2 block text-xs">Frequency Input</label>
                        <div class="relative">
                            <input type="number" id="frequency-output" class="w-full text-sm tabular-nums p-2 rounded-lg bg-gray-100 dark:bg-slate-700 text-gray-800 dark:text-gray-200 text-center pr-9" value="30">
                            <span class="absolute inset-y-0 right-0 flex items-center pr-3 text-sm text-gray-500 dark:text-gray-400 pointer-events-none">Hz</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Static Frequency Control -->
            <div id="frequency-control-wrapper" class="space-y-2">
                <!-- Bass Control -->
                <div>
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-center space-x-2">
                            <label for="bass-frequency" class="font-semibold text-gray-700 dark:text-gray-300 text-sm">Bass</label>
                            <button id="professional-mode-btn" class="p-1 text-xs font-semibold rounded-lg bg-gray-200 dark:bg-slate-600 hover:bg-gray-300 dark:hover:bg-slate-500">Pro Mode</button>
                            <span id="pro-mode-desc" class="text-xs text-gray-500 dark:text-gray-400"> - Finer control</span>
                        </div>
                        <div class="flex items-center space-x-2">
                            <span id="bass-range-label" class="text-xs text-gray-400">5 - 250 Hz</span>
                        </div>
                    </div>
                    <input type="range" id="bass-frequency" min="5" max="250" value="30" step="1" class="w-full custom-slider">
                </div>
                <!-- Mid and Treble Controls (Standard Mode) -->
                <div id="standard-freq-controls" class="space-y-2">
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label for="mid-frequency" class="font-semibold text-gray-700 dark:text-gray-300 text-sm">Mids</label>
                            <span class="text-xs text-gray-400">250 - 4000 Hz</span>
                        </div>
                        <input type="range" id="mid-frequency" min="250" max="4000" value="1000" step="1" class="w-full custom-slider">
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label for="treble-frequency" class="font-semibold text-gray-700 dark:text-gray-300 text-sm">Treble</label>
                            <span class="text-xs text-gray-400">4000 - 20000 Hz</span>
                        </div>
                        <input type="range" id="treble-frequency" min="4000" max="20000" value="8000" step="1" class="w-full custom-slider">
                    </div>
                </div>
            </div>
            
            <!-- Gain Control -->
            <div class="pt-4 mb-1 border-t border-gray-200 dark:border-gray-700">
                <div class="flex justify-between items-center mb-2">
                    <div class="flex items-center space-x-3">
                        <label for="gain" class="font-semibold text-gray-700 dark:text-gray-300 text-sm">Gain</label>
                        <!-- Volume Visualizer (Horizontal) -->
                        <div id="volume-visualizer" class="flex items-center justify-center space-y-1 flex-col" style="width: calc(140px - 0.5rem); height: 20px;">
                            <div class="flex items-center w-full">
                                <div class="text-xs font-medium text-gray-500 dark:text-gray-400 mr-1">L</div>
                                <div class="volume-bar bg-gray-600 dark:bg-gray-700 rounded-sm relative shadow-inner h-2 flex-1">
                                    <div class="volume-fill bg-orange-400 rounded-sm absolute left-0 top-0 bottom-0 transition-all duration-500 ease-out shadow-sm" style="width: 0%;"></div>
                                    <div class="volume-cap bg-gray-900 dark:bg-gray-800 absolute left-0 top-0 bottom-0 rounded-sm border border-gray-500" style="width: 2px;"></div>
                                </div>
                                <div class="volume-led-left-yellow w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200"></div>
                                <div class="volume-led-left-red w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200"></div>
                                <div class="text-xs font-medium text-gray-500 dark:text-gray-400 ml-1">clip</div>
                            </div>
                            <div class="flex items-center w-full">
                                <div class="text-xs font-medium text-gray-500 dark:text-gray-400 mr-1">R</div>
                                <div class="volume-bar bg-gray-600 dark:bg-gray-700 rounded-sm relative shadow-inner h-2 flex-1">
                                    <div class="volume-fill bg-orange-400 rounded-sm absolute left-0 top-0 bottom-0 transition-all duration-500 ease-out shadow-sm" style="width: 0%;"></div>
                                    <div class="volume-cap bg-gray-900 dark:bg-gray-800 absolute left-0 top-0 bottom-0 rounded-sm border border-gray-500" style="width: 2px;"></div>
                                </div>
                                <div class="volume-led-right-yellow w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200"></div>
                                <div class="volume-led-right-red w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200"></div>
                                <div class="text-xs font-medium text-gray-500 dark:text-gray-400 ml-1">clip</div>
                            </div>
                        </div>
                    </div>
                    <div class="flex items-center space-x-2">
                        <button id="gain-preset-7" class="px-2 py-1 text-xs font-semibold rounded-lg bg-gray-200 dark:bg-slate-600 hover:bg-gray-300 dark:hover:bg-slate-500">-7</button>
                        <button id="gain-preset-5" class="px-2 py-1 text-xs font-semibold rounded-lg bg-gray-200 dark:bg-slate-600 hover:bg-gray-300 dark:hover:bg-slate-500">-5</button>
                        <div id="gain-value-wrapper" class="flex items-center space-x-1 font-semibold px-2 py-0.5 rounded-full text-xs">
                            <input type="number" id="gain-input" value="-7.0" step="0.1" class="w-12 p-1 text-center bg-transparent tabular-nums">
                            <span>dB</span>
                        </div>
                    </div>
                </div>
                <input type="range" id="gain" min="-40" max="10" value="-7" step="0.1" class="w-full custom-slider">
            </div>

            <!-- Pan Control -->
            <div class="pt-2 mb-4">
                <div class="flex justify-between items-center mb-2">
                    <div class="flex items-center space-x-3">
                        <label for="pan" class="font-semibold text-gray-700 dark:text-gray-300 text-sm">Pan</label>
                    </div>
                    <div class="flex items-center space-x-2">
                        <span id="phase-display" class="text-xs font-semibold tabular-nums text-gray-500 dark:text-gray-400">Normal</span>
                        <button id="phase-btn" class="text-xs font-semibold rounded-lg bg-gray-200 dark:bg-slate-600 hover:bg-gray-300 dark:hover:bg-slate-500 px-3 py-1">Phase</button>
                    </div>
                </div>
                <div class="relative">
                    <input type="range" id="pan" min="-1" max="1" value="0" step="0.01" class="w-full custom-slider">
                    <div class="absolute top-[-2rem] left-1/2 transform -translate-x-1/2 flex items-center space-x-2">
                        <span id="pan-display-left" class="font-semibold text-xs tabular-nums text-gray-500 dark:text-gray-400 min-w-[3rem] text-right"></span>
                        <button id="recenter-pan-btn" class="text-xs font-bold rounded-full bg-gradient-to-br from-orange-400 to-amber-500 hover:from-orange-500 hover:to-amber-600 text-white shadow-lg hover:shadow-xl transition-all duration-200 px-3 h-6 flex items-center justify-center border-2 border-orange-300 hover:border-orange-400">Center</button>
                        <span id="pan-display-right" class="font-semibold text-xs tabular-nums text-gray-500 dark:text-gray-400 min-w-[3rem] text-left"></span>
                    </div>
                </div>
            </div>

            <!-- Frequency Sweep Control -->
            <div id="sweep-params" class="space-y-2 pt-2 hidden">
                <div class="grid grid-cols-2 gap-x-4 gap-y-3">
                    <div>
                        <label for="start-freq" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Start Freq (Hz)</label>
                        <input type="number" id="start-freq" value="100" class="w-full p-2 bg-gray-50 dark:bg-slate-700 border border-gray-300 dark:border-gray-600 rounded-lg text-sm placeholder-gray-500 dark:text-white" placeholder="e.g. 100">
                    </div>
                    <div>
                        <label for="end-freq" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">End Freq (Hz)</label>
                        <input type="number" id="end-freq" value="5000" class="w-full p-2 bg-gray-50 dark:bg-slate-700 border border-gray-300 dark:border-gray-600 rounded-lg text-sm placeholder-gray-500 dark:text-white" placeholder="e.g. 5000">
                    </div>
                    <div>
                        <label for="sweep-time" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Duration (s)</label>
                        <input type="number" id="sweep-time" value="5" class="w-full p-2 bg-gray-50 dark:bg-slate-700 border border-gray-300 dark:border-gray-600 rounded-lg text-sm placeholder-gray-500 dark:text-white" placeholder="e.g. 5">
                    </div>
                    <div>
                        <label for="sweep-type" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Scale</label>
                        <select id="sweep-type" class="w-full p-2 bg-gray-50 dark:bg-slate-700 border border-gray-300 dark:border-gray-600 rounded-lg text-sm dark:text-white">
                            <option value="linear">Linear</option>
                            <option value="logarithmic">Logarithmic</option>
                        </select>
                    </div>
                </div>
            </div>

             <!-- Warble Tone Control -->
            <div id="warble-params" class="space-y-2 pt-2 hidden">
                <div class="grid grid-cols-2 gap-x-4 gap-y-3">
                    <div>
                        <label for="warble-center-freq" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Center Freq (Hz)</label>
                        <input type="number" id="warble-center-freq" value="1000" class="w-full p-2 bg-gray-50 dark:bg-slate-700 border border-gray-300 dark:border-gray-600 rounded-lg text-sm">
                    </div>
                    <div>
                        <label for="warble-depth" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Depth (Hz)</label>
                        <input type="number" id="warble-depth" value="50" class="w-full p-2 bg-gray-50 dark:bg-slate-700 border border-gray-300 dark:border-gray-600 rounded-lg text-sm">
                    </div>
                     <div>
                        <label for="warble-speed" class="block text-xs font-medium text-gray-500 dark:text-gray-400 mb-1">Speed (Hz)</label>
                        <input type="number" id="warble-speed" value="5" class="w-full p-2 bg-gray-50 dark:bg-slate-700 border border-gray-300 dark:border-gray-600 rounded-lg text-sm">
                    </div>
                </div>
            </div>
        </main>
    </div>

        <div id="unit-converter-screen" class="hidden">
            <main class="sm:flex-grow-0 space-y-4">
                <div class="input-group">
                    <label for="combinedInput" class="font-semibold text-gray-700 dark:text-gray-300 mb-2 block text-sm">Enter a value (e.g., 16.875, 16 7/8, 428.62mm):</label>
                    <input type="text" id="combinedInput" placeholder="e.g., 16.875, 16 7/8, 428.62mm" class="w-full p-2 text-sm border rounded-lg dark:border-gray-600 dark:text-gray-300 bg-gray-50 dark:bg-slate-700 focus:ring-blue-500 focus:border-blue-500">
                </div>

            <div class="results space-y-4">
                <div class="result-group">
                    <h2 class="font-semibold text-gray-700 dark:text-gray-300 text-sm mb-2">Imperial Units</h2>
                    <div class="space-y-2">
                        <div class="result-item flex justify-between items-center p-3 bg-gray-50 dark:bg-slate-700 rounded-lg">
                            <span class="label text-sm text-gray-600 dark:text-gray-300">Inches (fraction)</span>
                            <span class="value font-bold text-gray-800 dark:text-white" id="fractionalResult">---</span>
                        </div>
                        <div class="result-item flex justify-between items-center p-3 bg-gray-50 dark:bg-slate-700 rounded-lg">
                            <span class="label text-sm text-gray-600 dark:text-gray-300">Inches (decimal)</span>
                            <span class="value font-bold text-gray-800 dark:text-white" id="decimalInchResult">---</span>
                        </div>
                        <div class="result-item flex justify-between items-center p-3 bg-gray-50 dark:bg-slate-700 rounded-lg">
                            <span class="label text-sm text-gray-600 dark:text-gray-300">Feet</span>
                            <span class="value font-bold text-gray-800 dark:text-white" id="feetResult">---</span>
                        </div>
                    </div>
                </div>

                <div class="result-group">
                    <h2 class="font-semibold text-gray-700 dark:text-gray-300 text-sm mb-2">Metric Units</h2>
                    <div class="space-y-2">
                        <div class="result-item flex justify-between items-center p-3 bg-gray-50 dark:bg-slate-700 rounded-lg">
                            <span class="label text-sm text-gray-600 dark:text-gray-300">Millimeters</span>
                            <span class="value font-bold text-gray-800 dark:text-white" id="mmResult">---</span>
                        </div>
                        <div class="result-item flex justify-between items-center p-3 bg-gray-50 dark:bg-slate-700 rounded-lg">
                            <span class="label text-sm text-gray-600 dark:text-gray-300">Centimeters</span>
                            <span class="value font-bold text-gray-800 dark:text-white" id="cmResult">---</span>
                        </div>
                        <div class="result-item flex justify-between items-center p-3 bg-gray-50 dark:bg-slate-700 rounded-lg">
                            <span class="label text-sm text-gray-600 dark:text-gray-300">Meters</span>
                            <span class="value font-bold text-gray-800 dark:text-white" id="mResult">---</span>
                        </div>
                    </div>
                </div>
            </div>
        </main>
    </div>

    <div id="polarity-checker-screen" class="hidden">
        <main class="sm:flex-grow-0">
            <!-- Professional Hardware-Style Polarity Checker -->
            <div class="polarity-hardware-panel bg-gray-800 rounded-2xl p-8 shadow-2xl">
                
                <!-- Header with LEDs -->
                <div class="flex justify-between items-center mb-8">
                    <div class="flex items-center space-x-4">
                        <div id="in-phase-led" class="w-3 h-3 rounded-full border border-green-400 bg-gray-600 transition-all duration-200"></div>
                        <span class="text-green-400 text-xs font-medium">IN PHASE</span>
                    </div>
                    <h2 class="text-white text-lg font-bold tracking-wider">POLARITY</h2>
                    <div class="flex items-center space-x-4">
                        <span class="text-red-400 text-xs font-medium">OUT OF PHASE</span>
                        <div id="out-of-phase-led" class="w-3 h-3 rounded-full border border-red-400 bg-gray-600 transition-all duration-200"></div>
                    </div>
                </div>

                <!-- Main Controls Area -->
                <div class="space-y-6 mb-8">
                    
                    <!-- Pop Speed Slider -->
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label for="pop-speed-slider" class="font-semibold text-gray-300 text-sm">Pop Speed</label>
                            <span id="pop-speed-value" class="text-xs text-gray-400">400ms</span>
                        </div>
                        <input type="range" id="pop-speed-slider" min="100" max="1000" value="400" step="50" class="w-full custom-slider">
                    </div>

                    <!-- Gain Slider -->
                    <div>
                        <div class="flex justify-between items-center mb-2">
                            <label for="gain-slider" class="font-semibold text-gray-300 text-sm">Gain</label>
                            <span id="gain-value" class="text-xs text-gray-400">30%</span>
                        </div>
                        <input type="range" id="gain-slider" min="0" max="100" value="30" step="5" class="w-full custom-slider">
                    </div>
                </div>

                <!-- Toggle Switch -->
                <div class="flex flex-col items-center mb-6">
                    <label class="text-gray-400 text-xs font-medium mb-2">POWER</label>
                    <label class="toggle-switch">
                        <input type="checkbox" id="polarityTestBtn">
                        <span class="toggle-slider"></span>
                    </label>
                    <span id="power-status" class="text-gray-400 text-xs mt-2">OFF</span>
                </div>

                <!-- Status Display -->
                <div id="polarity-result" class="text-center">
                    <div class="text-2xl font-bold text-gray-400">READY</div>
                </div>

                <!-- Instructions -->
                <p class="text-gray-500 text-xs text-center mt-6 leading-relaxed">
                    Adjust pop speed and gain, then press power to start continuous polarity testing.<br>
                    Microphone access required.
                </p>
            </div>
        </main>
    </div>

    <div id="file-analyzer-screen" class="hidden">
        <main class="sm:flex-grow-0 space-y-4">
            <div id="file-drop-area" class="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-xl p-8 text-center mb-5 transition-colors hover:border-gray-400 dark:hover:border-gray-500 hover:bg-gray-50 dark:hover:bg-slate-700/20 cursor-pointer">
                <svg class="w-12 h-12 mx-auto mb-4 text-gray-400 dark:text-gray-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l6-6v13M9 19c0 1.1.9 2 2 2h2c1.1 0 2-.9 2-2M9 19H7c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2h2m0 0V9h4V3"></path>
                </svg>
                <p class="text-lg font-medium text-gray-700 dark:text-gray-300 mb-2">Drop audio file here</p>
                <p class="text-sm text-gray-500 dark:text-gray-400 mb-3">or click to select</p>
                <p class="text-sm text-gray-600 dark:text-gray-400 mb-4 max-w-md mx-auto">Analyze audio files for quality metrics including THD+N, peak/RMS levels, and clipping detection. Automatically repair clipped audio with advanced de-clipping algorithms.</p>
                <p class="text-xs text-gray-400 dark:text-gray-500">Supports WAV, MP3, FLAC, OGG</p>
                <input type="file" id="file-input" accept="audio/*" class="hidden">
            </div>
            
            <!-- File Analyzer Action Buttons -->
            <div id="file-actions" class="hidden mb-6">
                <div class="space-y-3">
                    <!-- Load New File Button -->
                    <div class="flex justify-center">
                        <button id="load-new-file-btn" class="flex items-center space-x-2 px-4 py-2 text-sm font-medium text-blue-600 dark:text-blue-400 bg-blue-50 dark:bg-blue-900/30 hover:bg-blue-100 dark:hover:bg-blue-900/50 rounded-lg transition-colors border border-blue-200 dark:border-blue-800">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19V6l6-6v13M9 19c0 1.1.9 2 2 2h2c1.1 0 2-.9 2-2M9 19H7c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2h2m0 0V9h4V3"></path>
                            </svg>
                            <span>Load New File</span>
                        </button>
                        <input type="file" id="file-input-button" accept="audio/*" class="hidden">
                    </div>
                    
                    <!-- De-Clip Controls -->
                    <div id="declip-controls" class="hidden">
                        <div class="bg-amber-50 dark:bg-amber-900/20 border border-amber-200 dark:border-amber-800 rounded-lg p-4">
                            <div class="flex items-center space-x-2 mb-3">
                                <svg class="w-5 h-5 text-amber-600 dark:text-amber-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                                </svg>
                                <h3 class="text-sm font-semibold text-amber-800 dark:text-amber-200">Audio Clipping Detected</h3>
                            </div>
                            <p class="text-xs text-amber-700 dark:text-amber-300 mb-4">This audio file contains clipped samples. Use the de-clipping feature to repair the audio and download a corrected version.</p>
                            <div class="flex items-center justify-center space-x-3">
                                <label for="declip-format-select" class="text-sm font-medium text-amber-700 dark:text-amber-300">Format:</label>
                                <select id="declip-format-select" class="px-3 py-2 text-sm border rounded-lg dark:border-gray-600 dark:text-gray-300 bg-white dark:bg-slate-600 focus:ring-green-500 focus:border-green-500">
                                    <option value="wav">WAV</option>
                                    <option value="flac">FLAC</option>
                                    <option value="mp3">MP3</option>
                                </select>
                                <button id="declip-download-btn" class="flex items-center space-x-2 px-4 py-2 text-sm font-medium text-white bg-green-600 hover:bg-green-700 rounded-lg transition-colors shadow-sm">
                                    <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"></path>
                                    </svg>
                                    <span>De-Clip & Download</span>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="file-info" class="hidden bg-gray-50 dark:bg-slate-700 p-4 rounded-xl mb-5">
                <h3 class="text-lg font-medium text-gray-700 dark:text-gray-300 mb-4">File Information</h3>
                
                <!-- File Properties -->
                <div class="grid grid-cols-2 gap-3 text-sm mb-4">
                    <div><span class="text-gray-500 dark:text-gray-400">Name:</span> <span id="file-name" class="text-gray-800 dark:text-gray-200 font-medium">--</span></div>
                    <div><span class="text-gray-500 dark:text-gray-400">Duration:</span> <span id="file-duration" class="text-gray-800 dark:text-gray-200 font-medium">--</span></div>
                    <div><span class="text-gray-500 dark:text-gray-400">Sample Rate:</span> <span id="file-samplerate" class="text-gray-800 dark:text-gray-200 font-medium">--</span></div>
                    <div><span class="text-gray-500 dark:text-gray-400">Channels:</span> <span id="file-channels" class="text-gray-800 dark:text-gray-200 font-medium">--</span></div>
                </div>
                
                <!-- Audio Analysis Metrics -->
                <div id="file-analysis-metrics" class="hidden border-t border-gray-200 dark:border-gray-600 pt-4">
                    <div class="grid grid-cols-4 gap-4 text-center">
                        <div>
                            <div class="text-xs text-gray-500 dark:text-gray-400 mb-1">THD+N</div>
                            <div id="fileThdResult" class="text-lg font-bold text-gray-800 dark:text-gray-200">--.--%</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500 dark:text-gray-400 mb-1">Peak Level</div>
                            <div id="filePeakLevel" class="text-lg font-bold text-gray-800 dark:text-gray-200">-- dBFS</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500 dark:text-gray-400 mb-1">RMS Level</div>
                            <div id="fileRmsLevel" class="text-lg font-bold text-gray-800 dark:text-gray-200">-- dBFS</div>
                        </div>
                        <div>
                            <div class="text-xs text-gray-500 dark:text-gray-400 mb-1">Clipping</div>
                            <div id="fileClippingStatus" class="text-lg font-bold text-green-500 dark:text-green-400">OK</div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="file-analysis" class="hidden">
                <div class="bg-black p-4 rounded-xl">
                    <canvas id="fileWaveformCanvas" class="w-full h-80 rounded-lg"></canvas>
                </div>
            </div>
        </main>
    </div>

        <!-- Action Buttons Footer -->
        <footer id="app-footer" class="mt-auto pt-4 flex-shrink-0 space-y-2">
            <div class="flex items-center space-x-2">
                <button id="play-stop-button" class="flex-1 bg-gradient-to-r from-blue-600 to-blue-700 text-white font-semibold py-3 px-4 rounded-xl hover:from-blue-700 hover:to-blue-800 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:scale-[1.02] flex items-center justify-center space-x-2">
                    <svg id="play-icon" class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M8 5v14l11-7z"/>
                    </svg>
                    <svg id="stop-icon" class="w-5 h-5 hidden" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M6 6h12v12H6z"/>
                    </svg>
                    <span id="play-text">Play</span>
                </button>
                <button id="audio-output-button" class="flex-1 bg-gradient-to-r from-purple-600 to-purple-700 text-white font-semibold py-3 px-4 rounded-xl hover:from-purple-700 hover:to-purple-800 focus:outline-none focus:ring-4 focus:ring-purple-300 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:scale-[1.02] flex items-center justify-center space-x-2">
                    <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                    <span>Output Device</span>
                </button>
            </div>
            <button id="download-button" class="w-full bg-gradient-to-r from-green-600 to-green-700 text-white font-semibold py-3 px-4 rounded-xl hover:from-green-700 hover:to-green-800 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-200 shadow-lg hover:shadow-xl transform hover:scale-[1.02] flex items-center justify-center space-x-2 disabled:opacity-50 disabled:cursor-not-allowed">
                <svg class="w-5 h-5" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z"/>
                </svg>
                <span>Download audio snippet</span>
            </button>
        </footer>
    </div>

    <!-- Audio Output Modal -->
    <div id="audio-output-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
                    </svg>
                    Audio Output
                </h2>
                <button id="close-audio-output-btn" class="text-gray-500 hover:text-gray-800 dark:hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
                        <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                    </svg>
                </button>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="output-device-select" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Output Device</label>
                    <select id="output-device-select" class="w-full p-3 text-sm border rounded-lg dark:border-gray-600 dark:text-gray-300 bg-white dark:bg-slate-600 focus:ring-blue-500 focus:border-blue-500">
                        <option value="default">Default Audio Device</option>
                    </select>
                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Select which audio device to use for playback</p>
                </div>
                
                <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                    <h4 class="text-sm font-semibold text-blue-800 dark:text-blue-200 mb-2">Current Status</h4>
                    <div class="space-y-1 text-xs text-blue-700 dark:text-blue-300">
                        <div>State: <span id="audio-context-state" class="font-mono">Not initialized</span></div>
                        <div>Sample Rate: <span id="audio-context-samplerate" class="font-mono">--</span> Hz</div>
                    </div>
                </div>
                
                <div class="flex space-x-2 pt-2">
                    <button id="test-audio-button" class="flex-1 bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300 transition-all duration-200 flex items-center justify-center space-x-2">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M8 5v14l11-7z"/>
                        </svg>
                        <span>Test</span>
                    </button>
                    <button id="apply-audio-output-btn" class="flex-1 bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-200">
                        Apply
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Download Modal -->
    <div id="download-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white flex items-center">
                    <svg class="w-6 h-6 mr-2" fill="currentColor" viewBox="0 0 24 24">
                        <path d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z"/>
                    </svg>
                    Download Audio
                </h2>
                <button id="close-download-btn" class="text-gray-500 hover:text-gray-800 dark:hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
                        <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                    </svg>
                </button>
            </div>
            <div class="space-y-4">
                <div>
                    <label for="download-duration-select" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Duration</label>
                    <select id="download-duration-select" class="w-full p-3 text-sm border rounded-lg dark:border-gray-600 dark:text-gray-300 bg-white dark:bg-slate-600 focus:ring-blue-500 focus:border-blue-500">
                        <option value="5">5 seconds</option>
                        <option value="10">10 seconds</option>
                        <option value="15">15 seconds</option>
                        <option value="30" selected>30 seconds</option>
                        <option value="60">1 minute</option>
                        <option value="120">2 minutes</option>
                        <option value="300">5 minutes</option>
                    </select>
                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">Choose how long the audio snippet should be</p>
                </div>
                
                <div>
                    <label for="download-format-select" class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">Format</label>
                    <select id="download-format-select" class="w-full p-3 text-sm border rounded-lg dark:border-gray-600 dark:text-gray-300 bg-white dark:bg-slate-600 focus:ring-blue-500 focus:border-blue-500">
                        <option value="wav" selected>WAV (Uncompressed)</option>
                        <option value="flac">FLAC (Lossless)</option>
                        <option value="mp3">MP3 (Compressed)</option>
                    </select>
                    <p class="text-xs text-gray-500 dark:text-gray-400 mt-1">WAV offers best quality, MP3 smallest file size</p>
                </div>
                
                <div class="bg-blue-50 dark:bg-blue-900/20 border border-blue-200 dark:border-blue-800 rounded-lg p-3">
                    <h4 class="text-sm font-semibold text-blue-800 dark:text-blue-200 mb-2">Preview</h4>
                    <div class="space-y-1 text-xs text-blue-700 dark:text-blue-300">
                        <div>Tone: <span id="download-preview-tone" class="font-mono">30 Hz Sine</span></div>
                        <div>Duration: <span id="download-preview-duration" class="font-mono">30s</span></div>
                        <div>Format: <span id="download-preview-format" class="font-mono">WAV</span></div>
                    </div>
                </div>
                
                <div class="flex space-x-2 pt-2">
                    <button id="cancel-download-btn" class="flex-1 bg-gray-500 text-white font-semibold py-2 px-4 rounded-lg hover:bg-gray-600 focus:outline-none focus:ring-4 focus:ring-gray-300 transition-all duration-200">
                        Cancel
                    </button>
                    <button id="start-download-btn" class="flex-1 bg-green-600 text-white font-semibold py-2 px-4 rounded-lg hover:bg-green-700 focus:outline-none focus:ring-4 focus:ring-green-300 transition-all duration-200 flex items-center justify-center space-x-2">
                        <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 24 24">
                            <path d="M5 20h14v-2H5v2zM19 9h-4V3H9v6H5l7 7 7-7z"/>
                        </svg>
                        <span>Download</span>
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Changelog Modal -->
    <div id="changelog-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-lg max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white">Changelog</h2>
                <button id="close-changelog-btn" class="text-gray-500 hover:text-gray-800 dark:hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
                        <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                    </svg>
                </button>
            </div>
            <div class="overflow-y-auto flex-grow pr-2">
                <ul class="space-y-3 text-xs text-gray-600 dark:text-gray-300">
                    <li class="leading-relaxed">v0.9.6.7 (beta) - Added interactive play button abuse easter egg: triggers after 3 rapid clicks within 3 seconds, causing the play button to disappear and displaying a "System Overload" modal with custom-designed SVG car accident icon, error sound effect (descending harsh tones), and "I'm Sorry" acknowledgment requirement for recovery. Enhanced modal visual design with perfectly centered custom SVG featuring car silhouette, stick figure person, impact effects, and dramatic styling.</li>
                    <li class="leading-relaxed">v0.9.6.6 (beta) - Enhanced Professional Mode with improved UI behavior: fixed z-index layering issue where Pro Mode button appeared over modal dialogs, updated button styling to show orange text when active while maintaining original background, and extended bass frequency range to 90 Hz (up from 80 Hz) with 0.25 Hz precision. Additional UI improvements include redesigned pan control with "Center" button and repositioned percentage displays on either side, enhanced phase control with orange button text and red "Inverted" status display when phase is inverted, standardized gain preset buttons (-7dB, -5dB) with consistent styling and improved width for better visual balance, updated download button text to "Download audio snippet" for clarity, and implemented intelligent download preview descriptions that show appropriate labels for different sound types. Modernized Polarity Checker interface with professional slider controls: converted hardware-style knobs to sliders using the same CSS styling as the master generator, replaced circular power button with professional toggle switch featuring gradient backgrounds and smooth animations, enhanced visual feedback with ON/OFF status display. Fixed critical gain control bug caused by variable name conflict between main generator and polarity checker gain sliders by renaming polarity checker properties to unique identifiers.</li>
                    <li class="leading-relaxed">v0.9.6.5 (beta) - Major UI modernization with new "Output Device" button for audio device selection via modal popup, redesigned play button with gradient backgrounds and play/stop icons, shortened volume bars by 0.5rem, adjusted yellow LED threshold to -5.1 dB for precise audio level indication, changed default frequency to 30 Hz to match first preset, and replaced download dropdowns with comprehensive modal featuring duration selection (5s-5min), format options (WAV/FLAC/MP3), and live preview of download settings.</li>
                    <li class="leading-relaxed">v0.9.6.4 (beta) - Added volume bars for left and right channels with real-time audio level visualization, gradient color coding from green to red, and smooth animations that respond to pan control settings. Fixed dropdown layout issues: made "Tones" dropdown narrower with proper width constraints, improved presets dropdown sizing and spacing, and resolved flexbox conflicts that were causing alignment problems.</li>
                    <li class="leading-relaxed">v0.9.6.3 (beta) - Added "beta" text under version number display and made changelog modal scrollable with smaller text for better usability.</li>
                    <li class="leading-relaxed">v0.9.6.2 (beta) - Major polarity checker redesign with professional hardware-style interface featuring interactive knobs for pop speed and gain control, premium gradient backgrounds, realistic 3D knob styling with radial gradients and multi-layer shadows, enhanced LED indicators, professional power button with layered design, improved typography with color-coded labels, and structured information panels. Added custom mode configuration system with automatic mode switching suggestions.</li>
                    <li class="leading-relaxed">v0.9.6.1 (beta) - Added polarity checker screen with impulse generation and microphone analysis. Added file analyzer screen with professional waveform display, clipping detection, and de-clipping repair feature. Enhanced UI with better file action buttons layout and explanatory text. Fixed "Logs" button positioning to be static across all screens. Added Easter egg feature with click-triggered modal and programmatic "ta-da" sound generation.</li>
                    <li class="leading-relaxed">v0.9.6.0 (beta) - Integrated audio tools spectrum visualizer with colorful FFT bars and oscilloscope waveform display. Fixed blue, violet, and gray noise algorithms. Added Pro Mode decimal precision support to frequency input. Updated frequency input label.</li>
                    <li class="leading-relaxed">v0.9.5.9 (beta) - Hid irrelevant controls on unit converter screen.</li>
                    <li class="leading-relaxed">v0.9.5.8 (beta) - Added unit converter screen and main menu.</li>
                    <li class="leading-relaxed">v0.9.5.7 (beta) - Relocated frequency I/O box and reduced explainer text size.</li>
                    <li class="leading-relaxed">v0.9.5.6 (beta) - Adjusted title position.</li>
                    <li class="leading-relaxed">v0.9.5.5 (beta) - Changed app name, and numerous UI and layout adjustments.</li>
                    <li class="leading-relaxed">v0.9.5.4 (beta) - Added phase status display, removed pro mode input, and various layout adjustments.</li>
                    <li class="leading-relaxed">v0.9.5.3 (beta) - Added preset frequencies and adjusted label font sizes.</li>
                    <li class="leading-relaxed">v0.9.5.2 (beta) - Added changelog modal (idea by Jesse).</li>
                    <li class="leading-relaxed">v0.9.5.1 (beta) - Added phase inversion, fixed pan control layout, and eliminated audio popping.</li>
                    <li class="leading-relaxed">v0.9.5.0 (beta) - Added pan control and stereo download functionality.</li>
                </ul>
            </div>
        </div>
    </div>

    <!-- Menu Modal -->
    <div id="menu-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-xs">
            <div class="flex justify-between items-center mb-4">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white">Menu</h2>
                <button id="close-menu-btn" class="text-gray-500 hover:text-gray-800 dark:hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
                        <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                    </svg>
                </button>
            </div>
            <nav>
                <ul class="space-y-2">
                    <li><a href="#" id="show-generator-btn" class="block w-full text-left p-3 rounded-lg font-semibold text-gray-700 dark:text-gray-200 bg-gray-100 dark:bg-slate-700">Tone Generator</a></li>
                    <li><a href="#" id="show-converter-btn" class="block w-full text-left p-3 rounded-lg font-semibold text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-slate-700">Unit Converter</a></li>
                    <li><a href="#" id="show-polarity-btn" class="block w-full text-left p-3 rounded-lg font-semibold text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-slate-700">Polarity Checker</a></li>
                    <li><a href="#" id="show-file-analyzer-btn" class="block w-full text-left p-3 rounded-lg font-semibold text-gray-700 dark:text-gray-200 hover:bg-gray-100 dark:hover:bg-slate-700">File Analyzer</a></li>
                </ul>
            </nav>
        </div>
    </div>

    <!-- Tones & Sounds Information Modal -->
    <div id="tones-info-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-2xl max-h-[80vh] flex flex-col">
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white">Tones & Sounds Information</h2>
                <button id="close-tones-info-btn" class="text-gray-500 hover:text-gray-800 dark:hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
                        <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                    </svg>
                </button>
            </div>
            <div class="overflow-y-auto flex-grow pr-2">
                <div id="tones-info-content" class="space-y-4">
                    <!-- Content will be populated by JavaScript -->
                </div>
            </div>
        </div>
    </div>

    <!-- Easter Egg Modal -->
    <div id="easter-egg-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-8 w-full max-w-sm">
            <div class="relative mb-6">
                <h2 class="text-xl font-bold text-gray-800 dark:text-white text-center">Easter Egg</h2>
                <button id="close-easter-egg-btn" class="absolute top-0 right-0 text-gray-500 hover:text-gray-800 dark:hover:text-white">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" class="bi bi-x" viewBox="0 0 16 16">
                        <path d="M4.646 4.646a.5.5 0 0 1 .708 0L8 7.293l2.646-2.647a.5.5 0 0 1 .708.708L8.707 8l2.647 2.646a.5.5 0 0 1-.708.708L8 8.707l-2.646 2.647a.5.5 0 0 1-.708-.708L7.293 8 4.646 5.354a.5.5 0 0 1 0-.708z"/>
                    </svg>
                </button>
            </div>
            <div class="text-center">
                <div class="text-5xl mb-6 text-center">🎛️</div>
                <p class="text-gray-600 dark:text-gray-300 mb-6 text-center leading-relaxed text-base mx-auto">Hi, I'm a Master Generator, not to be confused with a ....... Actually nevermind.</p>
                <p class="text-sm text-gray-400 dark:text-gray-500 text-center">You found the secret</p>
            </div>
        </div>
    </div>

    <!-- Polarity Checker Warning Modal -->
    <div id="polarity-warning-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-6 w-full max-w-sm">
            <div class="flex items-center mb-4">
                <svg class="w-8 h-8 text-amber-500 mr-3" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-2.5L13.732 4c-.77-.833-1.732-.833-2.464 0L4.35 16.5c-.77.833.192 2.5 1.732 2.5z"></path>
                </svg>
                <h2 class="text-xl font-bold text-gray-800 dark:text-white">Warning</h2>
            </div>
            <p class="text-gray-600 dark:text-gray-300 mb-6 text-center">May not function correctly.</p>
            <div class="flex justify-center">
                <button id="acknowledge-polarity-warning-btn" class="bg-amber-500 hover:bg-amber-600 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                    Acknowledge
                </button>
            </div>
        </div>
    </div>

    <!-- Play Button Abuse Modal -->
    <div id="play-abuse-modal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white dark:bg-slate-800 rounded-lg shadow-xl p-8 w-full max-w-sm">
            <div class="text-center">
                <div class="flex justify-center mb-6">
                    <svg width="96" height="96" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                        <!-- Car body -->
                        <rect x="15" y="45" width="50" height="25" rx="3" fill="#2d3748"/>
                        <!-- Car windshield -->
                        <rect x="20" y="40" width="15" height="10" rx="2" fill="#2d3748"/>
                        <!-- Car wheels -->
                        <circle cx="25" cy="75" r="6" fill="#2d3748"/>
                        <circle cx="55" cy="75" r="6" fill="#2d3748"/>
                        <!-- Speed lines behind car -->
                        <line x1="5" y1="50" x2="12" y2="50" stroke="#2d3748" stroke-width="2"/>
                        <line x1="3" y1="55" x2="10" y2="55" stroke="#2d3748" stroke-width="2"/>
                        <line x1="7" y1="60" x2="14" y2="60" stroke="#2d3748" stroke-width="2"/>
                        
                        <!-- Person figure -->
                        <!-- Head -->
                        <circle cx="75" cy="25" r="8" fill="#2d3748"/>
                        <!-- Body -->
                        <rect x="70" y="33" width="10" height="20" rx="2" fill="#2d3748"/>
                        <!-- Arms (flailing) -->
                        <rect x="62" y="35" width="8" height="3" rx="1" fill="#2d3748" transform="rotate(-30 66 36.5)"/>
                        <rect x="80" y="35" width="8" height="3" rx="1" fill="#2d3748" transform="rotate(45 84 36.5)"/>
                        <!-- Legs -->
                        <rect x="68" y="53" width="4" height="12" rx="1" fill="#2d3748"/>
                        <rect x="78" y="53" width="4" height="12" rx="1" fill="#2d3748"/>
                        
                        <!-- Impact/crash effect -->
                        <g stroke="#ef4444" stroke-width="2" fill="none">
                            <line x1="65" y1="35" x2="72" y2="28"/>
                            <line x1="68" y1="32" x2="75" y2="25"/>
                            <line x1="70" y1="38" x2="77" y2="31"/>
                            <line x1="72" y1="42" x2="79" y2="35"/>
                        </g>
                        
                        <!-- Exclamation marks for emphasis -->
                        <text x="85" y="20" font-family="Arial, sans-serif" font-size="12" font-weight="bold" fill="#ef4444">!</text>
                        <text x="90" y="15" font-family="Arial, sans-serif" font-size="8" font-weight="bold" fill="#ef4444">!</text>
                    </svg>
                </div>
                <h2 class="text-xl font-bold text-gray-800 dark:text-white mb-4">System Overload</h2>
                <p class="text-gray-600 dark:text-gray-300 mb-6 text-center leading-relaxed">Please stop abusing me!</p>
                <p class="text-sm text-gray-400 dark:text-gray-500 text-center mb-6">The play button needs a moment to recover...</p>
                <button id="acknowledge-abuse-btn" class="bg-red-500 hover:bg-red-600 text-white font-semibold py-2 px-6 rounded-lg transition-colors">
                    I'm Sorry
                </button>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            /**
             * Main application object to encapsulate all functionality.
             * This avoids polluting the global namespace and organizes the code
             * into logical sections: elements, state, UI, audio, and visualizer.
             */
            const App = {
                // --- 1. Cache DOM Elements ---
                elements: {
                    // App Screens
                    toneGeneratorScreen: document.getElementById('tone-generator-screen'),
                    unitConverterScreen: document.getElementById('unit-converter-screen'),
                    polarityCheckerScreen: document.getElementById('polarity-checker-screen'),
                    fileAnalyzerScreen: document.getElementById('file-analyzer-screen'),
                    
                    // Volume Visualizer
                    volumeVisualizer: document.getElementById('volume-visualizer'),
                    volumeBars: document.querySelectorAll('.volume-fill'),
                    volumeLedLeftYellow: document.querySelector('.volume-led-left-yellow'),
                    volumeLedLeftRed: document.querySelector('.volume-led-left-red'),
                    volumeLedRightYellow: document.querySelector('.volume-led-right-yellow'),
                    volumeLedRightRed: document.querySelector('.volume-led-right-red'),
                    
                    // Gain Preset Buttons
                    gainPreset7: document.getElementById('gain-preset-7'),
                    gainPreset5: document.getElementById('gain-preset-5'),
                    
                    // Menu
                    menuBtn: document.getElementById('menu-btn'),
                    menuModal: document.getElementById('menu-modal'),
                    closeMenuBtn: document.getElementById('close-menu-btn'),
                    showGeneratorBtn: document.getElementById('show-generator-btn'),
                    showConverterBtn: document.getElementById('show-converter-btn'),
                    showPolarityBtn: document.getElementById('show-polarity-btn'),
                    showFileAnalyzerBtn: document.getElementById('show-file-analyzer-btn'),
                    showAudioOutputBtn: document.getElementById('show-audio-output-btn'),
                    
                    // Unit Converter
                    combinedInput: document.getElementById('combinedInput'),
                    fractionalResult: document.getElementById('fractionalResult'),
                    decimalInchResult: document.getElementById('decimalInchResult'),
                    feetResult: document.getElementById('feetResult'),
                    mmResult: document.getElementById('mmResult'),
                    cmResult: document.getElementById('cmResult'),
                    mResult: document.getElementById('mResult'),

                    // Tone Generator
                    bassFreqSlider: document.getElementById('bass-frequency'),
                    midFreqSlider: document.getElementById('mid-frequency'),
                    trebleFreqSlider: document.getElementById('treble-frequency'),
                    standardFreqControls: document.getElementById('standard-freq-controls'),
                    freqValue: document.getElementById('frequency-value'),
                    freqValueWrapper: document.getElementById('frequency-value-wrapper'),
                    freqUnit: document.getElementById('frequency-unit'),
                    frequencyMainInput: document.getElementById('frequency-main-input'),
                    frequencyTextDisplay: document.getElementById('frequency-text-display'),
                    gainSlider: document.getElementById('gain'),
                    gainInput: document.getElementById('gain-input'),
                    gainValueWrapper: document.getElementById('gain-value-wrapper'),
                    panSlider: document.getElementById('pan'),
                    panDisplayLeft: document.getElementById('pan-display-left'),
                    panDisplayRight: document.getElementById('pan-display-right'),
                    recenterPanBtn: document.getElementById('recenter-pan-btn'),
                    phaseBtn: document.getElementById('phase-btn'),
                    phaseDisplay: document.getElementById('phase-display'),
                    changelogBtn: document.getElementById('changelog-btn'),
                    changelogModal: document.getElementById('changelog-modal'),
                    closeChangelogBtn: document.getElementById('close-changelog-btn'),
                    soundTypeSelect: document.getElementById('sound-type-select'),
                    presetSelect: document.getElementById('preset-select'),
                    playStopButton: document.getElementById('play-stop-button'),
                    startFreq: document.getElementById('start-freq'),
                    endFreq: document.getElementById('end-freq'),
                    sweepTime: document.getElementById('sweep-time'),
                    sweepType: document.getElementById('sweep-type'),
                    freqControlWrapper: document.getElementById('frequency-control-wrapper'),
                    sweepParams: document.getElementById('sweep-params'),
                    warbleParams: document.getElementById('warble-params'),
                    warbleCenterFreq: document.getElementById('warble-center-freq'),
                    warbleDepth: document.getElementById('warble-depth'),
                    warbleSpeed: document.getElementById('warble-speed'),
                    professionalModeBtn: document.getElementById('professional-mode-btn'),
                    visualizerCanvas: document.getElementById('visualizer-canvas'),
                    viewToggleButton: document.getElementById('view-toggle-btn'),
                    wavelengthDisplay: document.getElementById('wavelength-display'),
                    icons: {
                        number: document.getElementById('icon-number'),
                        spectrogram: document.getElementById('icon-spectrogram'),
                        waveform: document.getElementById('icon-waveform'),
                        fft: document.getElementById('icon-fft'),
                    },
                    frequencyOutput: document.getElementById('frequency-output'),
                    downloadButton: document.getElementById('download-button'),
                    appTitle: document.querySelector('h1'),
                    appFooter: document.getElementById('app-footer'),
                    
                    // Audio Output elements
                    audioOutputButton: document.getElementById('audio-output-button'),
                    audioOutputModal: document.getElementById('audio-output-modal'),
                    closeAudioOutputBtn: document.getElementById('close-audio-output-btn'),
                    applyAudioOutputBtn: document.getElementById('apply-audio-output-btn'),
                    outputDeviceSelect: document.getElementById('output-device-select'),
                    audioContextState: document.getElementById('audio-context-state'),
                    audioContextSamplerate: document.getElementById('audio-context-samplerate'),
                    testAudioButton: document.getElementById('test-audio-button'),
                    playIcon: document.getElementById('play-icon'),
                    stopIcon: document.getElementById('stop-icon'),
                    playText: document.getElementById('play-text'),
                    
                    // Download Modal elements
                    downloadModal: document.getElementById('download-modal'),
                    closeDownloadBtn: document.getElementById('close-download-btn'),
                    cancelDownloadBtn: document.getElementById('cancel-download-btn'),
                    startDownloadBtn: document.getElementById('start-download-btn'),
                    downloadDurationSelect: document.getElementById('download-duration-select'),
                    downloadFormatSelect: document.getElementById('download-format-select'),
                    downloadPreviewTone: document.getElementById('download-preview-tone'),
                    downloadPreviewDuration: document.getElementById('download-preview-duration'),
                    downloadPreviewFormat: document.getElementById('download-preview-format'),
                    
                    // Polarity Checker elements
                    polarityResult: document.getElementById('polarity-result'),
                    polarityTestBtn: document.getElementById('polarityTestBtn'),
                    powerStatus: document.getElementById('power-status'),
                    inPhaseLed: document.getElementById('in-phase-led'),
                    outOfPhaseLed: document.getElementById('out-of-phase-led'),
                    popSpeedSlider: document.getElementById('pop-speed-slider'),
                    polarityGainSlider: document.getElementById('gain-slider'),
                    popSpeedValue: document.getElementById('pop-speed-value'),
                    polarityGainValue: document.getElementById('gain-value'),
                    
                    // File Analyzer elements
                    fileDropArea: document.getElementById('file-drop-area'),
                    fileInput: document.getElementById('file-input'),
                    fileInfo: document.getElementById('file-info'),
                    fileName: document.getElementById('file-name'),
                    fileDuration: document.getElementById('file-duration'),
                    fileSampleRate: document.getElementById('file-samplerate'),
                    fileChannels: document.getElementById('file-channels'),
                    fileAnalysis: document.getElementById('file-analysis'),
                    fileThdResult: document.getElementById('fileThdResult'),
                    filePeakLevel: document.getElementById('filePeakLevel'),
                    fileRmsLevel: document.getElementById('fileRmsLevel'),
                    fileWaveformCanvas: document.getElementById('fileWaveformCanvas'),
                    fileClippingStatus: document.getElementById('fileClippingStatus'),
                    declipDownloadBtn: document.getElementById('declip-download-btn'),
                    declipFormatSelect: document.getElementById('declip-format-select'),
                    fileActions: document.getElementById('file-actions'),
                    declipControls: document.getElementById('declip-controls'),
                    
                    // Easter Egg elements
                    easterEggModal: document.getElementById('easter-egg-modal'),
                    closeEasterEggBtn: document.getElementById('close-easter-egg-btn'),
                    
                    // Tones Info Modal elements
                    tonesInfoBtn: document.getElementById('tones-info-btn'),
                    tonesInfoModal: document.getElementById('tones-info-modal'),
                    closeTonesInfoBtn: document.getElementById('close-tones-info-btn'),
                    tonesInfoContent: document.getElementById('tones-info-content'),
                    
                    // Polarity Warning Modal elements
                    polarityWarningModal: document.getElementById('polarity-warning-modal'),
                    acknowledgePolarityWarningBtn: document.getElementById('acknowledge-polarity-warning-btn'),
                    
                    // Play Button Abuse Modal elements
                    playAbuseModal: document.getElementById('play-abuse-modal'),
                    acknowledgeAbuseBtn: document.getElementById('acknowledge-abuse-btn'),
                },

                // --- 2. Application State ---
                state: {
                    audioContext: null,
                    sourceNode: null,
                    gainNode: null,
                    pannerNode: null,
                    phaseInvertNode: null,
                    analyser: null,
                    isPlaying: false,
                    animationFrameId: null,
                    sweepTimeoutId: null,
                    visualizerCtx: null,
                    currentViewMode: 0, // 0: Number, 1: FFT, 2: Spectrogram, 3: Waveform
                    isProfessionalMode: false,
                    noiseProcessorUrl: null,
                    autoViewChanged: false, // Flag to track if view was auto-switched for noise
                    previousSoundType: 'sine',
                    isPhaseInverted: false,
                    
                    // Easter egg state
                    titleClickCount: 0,
                    titleClickTimeout: null,
                    
                    // Polarity warning state
                    polarityWarningShown: false,
                    
                    // Play button abuse detection
                    playButtonClickCount: 0,
                    playButtonClickTimeout: null,
                    playButtonAbused: false,
                },

                // --- 3. Initialization ---
                init() {
                    this.audio.createNoiseProcessor();
                    this.ui.addEventListeners();
                    this.converter.init();
                    this.ui.updateState();
                    this.ui.updateGainColor(this.elements.gainSlider.value);
                    this.ui.updateFrequencyDisplay(this.elements.bassFreqSlider.value);
                    this.ui.updatePanDisplay(this.elements.panSlider.value);
                },

                // --- 4. UI Module ---
                ui: {
                    addEventListeners() {
                        const elements = App.elements;

                        // Menu controls
                        elements.menuBtn.addEventListener('click', () => this.showMenu(true));
                        elements.closeMenuBtn.addEventListener('click', () => this.showMenu(false));
                        elements.menuModal.addEventListener('click', (e) => {
                            if (e.target === elements.menuModal) this.showMenu(false);
                        });
                        elements.showGeneratorBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.switchScreen('generator');
                        });
                        elements.showConverterBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.switchScreen('converter');
                        });
                        elements.showPolarityBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.switchScreen('polarity');
                        });
                        elements.showFileAnalyzerBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            this.switchScreen('file-analyzer');
                        });
                        // Audio output button
                        elements.audioOutputButton.addEventListener('click', () => {
                            this.showAudioOutputModal();
                        });

                        elements.playStopButton.addEventListener('click', () => this.handlePlayButtonClick());
                        elements.viewToggleButton.addEventListener('click', () => {
                            App.state.autoViewChanged = false; // User is taking manual control
                            this.toggleView();
                        });
                        elements.professionalModeBtn.addEventListener('click', () => {
                            console.log('Pro mode button clicked');
                            this.toggleProfessionalMode()
                        });
                        elements.soundTypeSelect.addEventListener('change', () => {
                            const previousSoundType = App.state.previousSoundType;
                            const soundType = App.elements.soundTypeSelect.value;
                            const isPreviousNoise = ['white', 'pink', 'brown', 'blue', 'violet', 'gray'].includes(previousSoundType);
                            const isCurrentNoise = ['white', 'pink', 'brown', 'blue', 'violet', 'gray'].includes(soundType);

                            this.updateState();

                            if (isCurrentNoise) {
                                if (!isPreviousNoise) {
                                    if (App.state.currentViewMode === 0) {
                                        App.state.autoViewChanged = true;
                                    }
                                    this.setView(1);
                                }
                            } else {
                                if (App.state.autoViewChanged) {
                                    this.setView(0);
                                    App.state.autoViewChanged = false;
                                }
                            }

                            App.state.previousSoundType = soundType;

                            if (App.state.isPlaying) {
                                App.audio.stop();
                                App.audio.play();
                            }
                        });

                        const handleFreqSlider = (e) => {
                            const freq = parseFloat(e.target.value);
                            this.updateFrequencyDisplay(freq);
                            App.audio.setFrequency(freq);
                        };
                        const handleBassChange = () => {
                            const freq = parseFloat(elements.bassFreqSlider.value);
                            this.updateFrequencyDisplay(freq);
                            App.audio.setFrequency(freq);
                        };

                        elements.bassFreqSlider.addEventListener('input', handleBassChange);

                        elements.midFreqSlider.addEventListener('input', handleFreqSlider);
                        elements.trebleFreqSlider.addEventListener('input', handleFreqSlider);

                        elements.gainSlider.addEventListener('input', () => {
                            const db = elements.gainSlider.value;
                            elements.gainInput.value = parseFloat(db).toFixed(1);
                            this.updateGainColor(db);
                            App.audio.setGain(db);
                        });

                        elements.gainInput.addEventListener('change', () => {
                            let db = parseFloat(elements.gainInput.value);
                            if (isNaN(db)) return;
                            db = Math.max(-40, Math.min(10, db));
                            elements.gainSlider.value = db;
                            this.updateGainColor(db);
                            App.audio.setGain(db);
                        });

                        // Gain preset buttons
                        elements.gainPreset7.addEventListener('click', () => {
                            const db = -7;
                            elements.gainSlider.value = db;
                            elements.gainInput.value = db.toFixed(1);
                            this.updateGainColor(db);
                            App.audio.setGain(db);
                        });

                        elements.gainPreset5.addEventListener('click', () => {
                            const db = -5;
                            elements.gainSlider.value = db;
                            elements.gainInput.value = db.toFixed(1);
                            this.updateGainColor(db);
                            App.audio.setGain(db);
                        });


                        elements.panSlider.addEventListener('input', () => {
                            const panValue = parseFloat(elements.panSlider.value);
                            this.updatePanDisplay(panValue);
                            App.audio.setPan(panValue);
                        });

                        elements.recenterPanBtn.addEventListener('click', () => {
                            elements.panSlider.value = 0;
                            this.updatePanDisplay(0);
                            App.audio.setPan(0);
                        });

                        elements.phaseBtn.addEventListener('click', () => {
                            App.state.isPhaseInverted = !App.state.isPhaseInverted;
                            elements.phaseBtn.classList.toggle('bg-blue-600', App.state.isPhaseInverted);
                            elements.phaseBtn.classList.toggle('text-orange-500', App.state.isPhaseInverted);
                            elements.phaseDisplay.classList.toggle('text-red-500', App.state.isPhaseInverted);
                            elements.phaseDisplay.textContent = App.state.isPhaseInverted ? 'Inverted' : 'Normal';
                            App.audio.setPhase(App.state.isPhaseInverted);
                        });

                        elements.changelogBtn.addEventListener('click', () => {
                            elements.changelogModal.classList.remove('hidden');
                            elements.changelogBtn.classList.add('hidden');
                        });

                        elements.closeChangelogBtn.addEventListener('click', () => {
                            elements.changelogModal.classList.add('hidden');
                            elements.changelogBtn.classList.remove('hidden');
                        });

                        elements.changelogModal.addEventListener('click', (e) => {
                            if (e.target === elements.changelogModal) {
                                elements.changelogModal.classList.add('hidden');
                                elements.changelogBtn.classList.remove('hidden');
                            }
                        });

                        elements.freqValueWrapper.addEventListener('click', () => this.showFrequencyInput());
                        elements.frequencyMainInput.addEventListener('blur', () => this.handleMainFreqInput());
                        elements.frequencyMainInput.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter') elements.frequencyMainInput.blur();
                        });

                        elements.frequencyOutput.addEventListener('change', () => {
                            // Use parseFloat for Pro Mode to support decimal values
                            let freq = App.state.isProfessionalMode
                                ? parseFloat(elements.frequencyOutput.value)
                                : parseInt(elements.frequencyOutput.value, 10);
                            freq = isNaN(freq) ? 440 : Math.max(5, Math.min(20000, freq));
                            
                            if (freq <= 250) {
                                elements.bassFreqSlider.value = freq;
                            } else if (freq > 250 && freq <= 4000) {
                                elements.midFreqSlider.value = freq;
                            } else {
                                elements.trebleFreqSlider.value = freq;
                            }
                            
                            this.updateFrequencyDisplay(freq);
                            App.audio.setFrequency(freq);
                        });

                        elements.downloadButton.addEventListener('click', () => this.showDownloadModal());

                        elements.presetSelect.addEventListener('change', (e) => {
                            const freq = parseFloat(e.target.value);
                            this.updateFrequencyDisplay(freq);
                            App.audio.setFrequency(freq);
                            if (freq <= 250) {
                                elements.bassFreqSlider.value = freq;
                            } else if (freq > 250 && freq <= 4000) {
                                elements.midFreqSlider.value = freq;
                            } else {
                                elements.trebleFreqSlider.value = freq;
                            }
                        });

                        // Easter egg - title click handler
                        elements.appTitle.addEventListener('click', () => this.handleTitleClick());
                        elements.closeEasterEggBtn.addEventListener('click', () => this.closeEasterEgg());
                        elements.easterEggModal.addEventListener('click', (e) => {
                            if (e.target === elements.easterEggModal) this.closeEasterEgg();
                        });

                        // Tones info modal handlers
                        elements.tonesInfoBtn.addEventListener('click', () => this.showTonesInfo());
                        elements.closeTonesInfoBtn.addEventListener('click', () => this.closeTonesInfo());
                        elements.tonesInfoModal.addEventListener('click', (e) => {
                            if (e.target === elements.tonesInfoModal) this.closeTonesInfo();
                        });
                        
                        // Audio output modal handlers
                        elements.closeAudioOutputBtn.addEventListener('click', () => this.closeAudioOutputModal());
                        elements.applyAudioOutputBtn.addEventListener('click', () => this.applyAudioOutputSettings());
                        elements.testAudioButton.addEventListener('click', () => App.audioOutput.testAudio());
                        elements.outputDeviceSelect.addEventListener('change', () => App.audioOutput.updateDevice());
                        elements.audioOutputModal.addEventListener('click', (e) => {
                            if (e.target === elements.audioOutputModal) this.closeAudioOutputModal();
                        });
                        
                        // Download modal handlers
                        elements.closeDownloadBtn.addEventListener('click', () => this.closeDownloadModal());
                        elements.cancelDownloadBtn.addEventListener('click', () => this.closeDownloadModal());
                        elements.startDownloadBtn.addEventListener('click', () => this.startDownload());
                        elements.downloadDurationSelect.addEventListener('change', () => this.updateDownloadPreview());
                        elements.downloadFormatSelect.addEventListener('change', () => this.updateDownloadPreview());
                        elements.downloadModal.addEventListener('click', (e) => {
                            if (e.target === elements.downloadModal) this.closeDownloadModal();
                        });

                        // Polarity warning modal handlers
                        elements.acknowledgePolarityWarningBtn.addEventListener('click', () => this.closePolarityWarning());
                        elements.polarityWarningModal.addEventListener('click', (e) => {
                            if (e.target === elements.polarityWarningModal) this.closePolarityWarning();
                        });
                        
                        // Play button abuse modal handlers
                        elements.acknowledgeAbuseBtn.addEventListener('click', () => this.closePlayAbuseModal());
                        elements.playAbuseModal.addEventListener('click', (e) => {
                            if (e.target === elements.playAbuseModal) this.closePlayAbuseModal();
                        });
                    },

                    handleTitleClick() {
                        App.state.titleClickCount++;
                        
                        // Reset counter after 2 seconds of no clicks
                        if (App.state.titleClickTimeout) {
                            clearTimeout(App.state.titleClickTimeout);
                        }
                        App.state.titleClickTimeout = setTimeout(() => {
                            App.state.titleClickCount = 0;
                        }, 2000);
                        
                        // Show easter egg after 3+ clicks
                        if (App.state.titleClickCount >= 3) {
                            this.showEasterEgg();
                            App.state.titleClickCount = 0; // Reset counter
                        }
                    },

                    showEasterEgg() {
                        this.playTadaSound();
                        App.elements.easterEggModal.classList.remove('hidden');
                    },

                    playTadaSound() {
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            
                            // Create a "ta-da" sound using multiple tones
                            const playNote = (frequency, startTime, duration, volume = 0.1) => {
                                const oscillator = audioContext.createOscillator();
                                const gainNode = audioContext.createGain();
                                
                                oscillator.connect(gainNode);
                                gainNode.connect(audioContext.destination);
                                
                                oscillator.frequency.setValueAtTime(frequency, startTime);
                                oscillator.type = 'sine';
                                
                                // Envelope for smooth attack and decay
                                gainNode.gain.setValueAtTime(0, startTime);
                                gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.05);
                                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                                
                                oscillator.start(startTime);
                                oscillator.stop(startTime + duration);
                            };
                            
                            // Ta-da chord progression (C major chord with flourish)
                            const now = audioContext.currentTime;
                            
                            // First chord (C major)
                            playNote(523.25, now, 0.8, 0.08); // C5
                            playNote(659.25, now, 0.8, 0.08); // E5
                            playNote(783.99, now, 0.8, 0.08); // G5
                            
                            // Flourish notes
                            playNote(1046.50, now + 0.3, 0.6, 0.06); // C6
                            playNote(1318.51, now + 0.5, 0.4, 0.05); // E6
                            
                        } catch (error) {
                            console.log('Audio context not available for Easter egg sound');
                        }
                    },

                    closeEasterEgg() {
                        App.elements.easterEggModal.classList.add('hidden');
                    },

                    showTonesInfo() {
                        this.populateTonesInfo();
                        App.elements.tonesInfoModal.classList.remove('hidden');
                    },

                    closeTonesInfo() {
                        App.elements.tonesInfoModal.classList.add('hidden');
                    },

                    populateTonesInfo() {
                        const tonesData = [
                            {
                                type: 'sine',
                                title: 'Sine Wave',
                                description: 'A pure, smooth tone with no overtones. The most basic building block of sound.'
                            },
                            {
                                type: 'square',
                                title: 'Square Wave',
                                description: 'A harsher, brighter tone with odd-numbered harmonics. Sounds buzzy or electronic.'
                            },
                            {
                                type: 'sawtooth',
                                title: 'Sawtooth Wave',
                                description: 'A very bright, rich, and buzzy tone containing all harmonics.'
                            },
                            {
                                type: 'triangle',
                                title: 'Triangle Wave',
                                description: 'A sound between a sine and square wave, with a mellow, flute-like quality.'
                            },
                            {
                                type: 'sweep',
                                title: 'Frequency Sweep',
                                description: 'A sine wave that smoothly glides from a start to an end frequency. Used for finding resonances.'
                            },
                            {
                                type: 'white',
                                title: 'White Noise',
                                description: 'Contains equal energy at all frequencies. Sounds like static or hiss.'
                            },
                            {
                                type: 'pink',
                                title: 'Pink Noise',
                                description: 'Energy decreases as frequency increases. Sounds more balanced and natural than white noise.'
                            },
                            {
                                type: 'brown',
                                title: 'Brown Noise',
                                description: 'Has more energy at lower frequencies. Sounds deeper, like a heavy waterfall or thunder.'
                            },
                            {
                                type: 'blue',
                                title: 'Blue Noise',
                                description: 'Energy increases as frequency rises. Sounds brighter and harsher than white noise.'
                            },
                            {
                                type: 'violet',
                                title: 'Violet Noise',
                                description: 'Energy rises even more steeply with frequency than blue noise. Very bright and hissy.'
                            },
                            {
                                type: 'gray',
                                title: 'Gray Noise',
                                description: 'Perceptually equal in loudness across all frequencies, designed to be flat to the human ear.'
                            },
                            {
                                type: 'warble',
                                title: 'Warble Tone',
                                description: 'A sine wave that rapidly fluctuates around a center frequency. Excellent for finding rattles.'
                            },
                            {
                                type: 'imd',
                                title: 'IMD Test',
                                description: 'Plays two tones (60 Hz & 7 kHz) simultaneously to test for Intermodulation Distortion in audio equipment.'
                            }
                        ];

                        let content = '';
                        tonesData.forEach(tone => {
                            content += `
                                <div class="p-4 bg-gray-50 dark:bg-slate-700 rounded-lg">
                                    <h3 class="font-bold text-gray-800 dark:text-white text-lg mb-2">${tone.title}</h3>
                                    <p class="text-gray-600 dark:text-gray-300 text-sm leading-relaxed">${tone.description}</p>
                                </div>
                            `;
                        });

                        App.elements.tonesInfoContent.innerHTML = content;
                    },

                    showMenu(visible) {
                        App.elements.menuModal.classList.toggle('hidden', !visible);
                    },

                    switchScreen(screen) {
                        const { elements } = App;
                        const isGenerator = screen === 'generator';
                        const isConverter = screen === 'converter';
                        const isPolarity = screen === 'polarity';
                        const isFileAnalyzer = screen === 'file-analyzer';

                        elements.toneGeneratorScreen.classList.toggle('hidden', !isGenerator);
                        elements.unitConverterScreen.classList.toggle('hidden', !isConverter);
                        elements.polarityCheckerScreen.classList.toggle('hidden', !isPolarity);
                        elements.fileAnalyzerScreen.classList.toggle('hidden', !isFileAnalyzer);
                        
                        if (isGenerator) {
                            elements.appTitle.textContent = 'Master Generator';
                        } else if (isConverter) {
                            elements.appTitle.textContent = 'Unit Converter';
                        } else if (isPolarity) {
                            elements.appTitle.textContent = 'Polarity Checker';
                        } else if (isFileAnalyzer) {
                            elements.appTitle.textContent = 'File Analyzer';
                        }
                        
                        // Show/hide elements based on the active screen
                        elements.appFooter.classList.toggle('hidden', !isGenerator);
                        elements.viewToggleButton.classList.toggle('hidden', !isGenerator);

                        // Update active button style
                        elements.showGeneratorBtn.classList.toggle('bg-gray-100', isGenerator);
                        elements.showGeneratorBtn.classList.toggle('dark:bg-slate-700', isGenerator);
                        elements.showConverterBtn.classList.toggle('bg-gray-100', isConverter);
                        elements.showConverterBtn.classList.toggle('dark:bg-slate-700', isConverter);
                        elements.showPolarityBtn.classList.toggle('bg-gray-100', isPolarity);
                        elements.showPolarityBtn.classList.toggle('dark:bg-slate-700', isPolarity);
                        elements.showFileAnalyzerBtn.classList.toggle('bg-gray-100', isFileAnalyzer);
                        elements.showFileAnalyzerBtn.classList.toggle('dark:bg-slate-700', isFileAnalyzer);

                        // If switching back to generator screen while audio is playing, reinitialize visualizer
                        if (isGenerator && App.state.isPlaying) {
                            // Reinitialize the visualizer context and restore proper view mode
                            setTimeout(() => {
                                App.visualizer.initializeVisualizer();
                                this.setView(App.state.currentViewMode);
                            }, 50); // Small delay to ensure DOM is updated
                        }

                        this.showMenu(false);
                        
                        // Show polarity warning if switching to polarity checker for the first time
                        if (isPolarity && !App.state.polarityWarningShown) {
                            setTimeout(() => this.showPolarityWarning(), 300);
                        }
                    },

                    toggleProfessionalMode() {
                        App.state.isProfessionalMode = !App.state.isProfessionalMode;
                        const isPro = App.state.isProfessionalMode;
                        const elements = App.elements;
                        const bassRangeLabel = document.getElementById('bass-range-label');

                        // Toggle visibility of standard controls
                        elements.standardFreqControls.classList.toggle('hidden', isPro);

                        // Update bass slider attributes
                        if (isPro) {
                            elements.bassFreqSlider.max = 90;
                            elements.bassFreqSlider.step = 0.25;
                            bassRangeLabel.textContent = "5 - 90 Hz";
                            if (parseFloat(elements.bassFreqSlider.value) > 90) {
                                elements.bassFreqSlider.value = 90;
                            }
                        } else {
                            elements.bassFreqSlider.max = 250;
                            elements.bassFreqSlider.step = 1;
                            bassRangeLabel.textContent = "5 - 250 Hz";
                        }
                        
                        // Update frequency output box step for Pro Mode
                        elements.frequencyOutput.step = isPro ? 0.25 : 1;
                        
                        // Update button style - only change text color to orange when active
                        elements.professionalModeBtn.classList.toggle('text-orange-500', isPro);


                        // Sync and update display
                        const currentFreq = parseFloat(elements.bassFreqSlider.value);
                        this.updateFrequencyDisplay(currentFreq);
                        App.audio.setFrequency(currentFreq);
                    },

                    updateState() {
                        const soundType = App.elements.soundTypeSelect.value;
                        const isNoise = ['white', 'pink', 'brown', 'blue', 'violet', 'gray'].includes(soundType);
                        const isSweep = soundType === 'sweep';
                        const isWarble = soundType === 'warble';
                        const isIMD = soundType === 'imd';
                        const disableFreqControls = isNoise || isSweep || isWarble || isIMD;

                        App.elements.freqControlWrapper.classList.toggle('hidden', disableFreqControls);
                        
                        App.elements.sweepParams.classList.toggle('hidden', !isSweep);
                        App.elements.warbleParams.classList.toggle('hidden', !isWarble);

                    },
                    
                    setView(mode) {
                        App.state.currentViewMode = mode;
                        const elements = App.elements;
                        elements.freqValueWrapper.classList.toggle('hidden', mode !== 0);
                        elements.visualizerCanvas.classList.toggle('hidden', mode === 0);
                        Object.values(elements.icons).forEach(icon => icon.classList.add('hidden'));
                        const iconMap = ['number', 'fft', 'spectrogram', 'waveform'];
                        if (elements.icons[iconMap[mode]]) {
                            elements.icons[iconMap[mode]].classList.remove('hidden');
                        }
                    },

                    toggleView() {
                        const newMode = (App.state.currentViewMode + 1) % 4;
                        this.setView(newMode);
                    },

                    updatePlayButton(playing) {
                        const button = App.elements.playStopButton;
                        const playIcon = App.elements.playIcon;
                        const stopIcon = App.elements.stopIcon;
                        const playText = App.elements.playText;
                        
                        if (playing) {
                            playIcon.classList.add('hidden');
                            stopIcon.classList.remove('hidden');
                            playText.textContent = 'Stop';
                            button.classList.remove('from-blue-600', 'to-blue-700', 'hover:from-blue-700', 'hover:to-blue-800');
                            button.classList.add('from-red-600', 'to-red-700', 'hover:from-red-700', 'hover:to-red-800');
                        } else {
                            playIcon.classList.remove('hidden');
                            stopIcon.classList.add('hidden');
                            playText.textContent = 'Play';
                            button.classList.remove('from-red-600', 'to-red-700', 'hover:from-red-700', 'hover:to-red-800');
                            button.classList.add('from-blue-600', 'to-blue-700', 'hover:from-blue-700', 'hover:to-blue-800');
                        }
                    },

                    updateFrequencyDisplay(freq) {
                        if (!freq && freq !==0) return;
                        const displayFreq = App.state.isProfessionalMode ? freq.toFixed(2) : Math.round(freq);
                        App.elements.freqValue.textContent = displayFreq;

                        if (App.elements.frequencyOutput) {
                            // Show decimal precision in Pro Mode
                            App.elements.frequencyOutput.value = App.state.isProfessionalMode
                                ? freq.toFixed(2)
                                : Math.round(freq);
                        }

                        this.updateFrequencyColor(freq);
                        this.updateWavelengthDisplay(freq);
                    },
                    
                    updateFrequencyColor(freq) {
                        const valueText = App.elements.freqValue;
                        const unitText = App.elements.freqUnit;
                        const output = App.elements.frequencyOutput;

                        const textColors = {
                            red: ['text-red-600', 'dark:text-red-400'],
                            yellow: ['text-yellow-500', 'dark:text-yellow-300'],
                            green: ['text-green-500', 'dark:text-green-400'],
                            default: ['text-white']
                        };
                        
                        const outputColors = {
                            red: ['bg-red-200', 'text-red-800', 'dark:bg-red-900/60', 'dark:text-red-200'],
                            yellow: ['bg-yellow-200', 'text-yellow-800', 'dark:bg-yellow-800/50', 'dark:text-yellow-200'],
                            green: ['bg-green-200', 'text-green-800', 'dark:bg-green-800/50', 'dark:text-green-200'],
                            default: ['bg-gray-100', 'dark:bg-slate-700', 'text-gray-800', 'dark:text-gray-200']
                        };

                        // Clear existing colors
                        Object.values(textColors).flat().forEach(cls => {
                            valueText.classList.remove(cls);
                            unitText.classList.remove(cls);
                        });
                         if (output) {
                            Object.values(outputColors).flat().forEach(cls => output.classList.remove(cls));
                        }

                        // Apply new colors
                        let textColor, outputColor;
                        if (freq < 250) {
                            textColor = textColors.red;
                            outputColor = outputColors.red;
                        } else if (freq >= 250 && freq < 4000) {
                            textColor = textColors.yellow;
                            outputColor = outputColors.yellow;
                        } else if (freq >= 4000) {
                            textColor = textColors.green;
                            outputColor = outputColors.green;
                        } else {
                            textColor = textColors.default;
                            outputColor = outputColors.default;
                        }
                        
                        valueText.classList.add(...textColor);
                        unitText.classList.add(...textColor);
                        if (output) {
                            output.classList.add(...outputColor);
                        }
                    },

                    updateWavelengthDisplay(freq) {
                        if (freq > 0) {
                            // Metric calculation
                            const speedOfSoundMetric = 343; // m/s
                            const wavelengthMeters = speedOfSoundMetric / freq;
                            const metricDisplay = wavelengthMeters < 1
                                ? `${(wavelengthMeters * 100).toFixed(1)} cm`
                                : `${wavelengthMeters.toFixed(2)} m`;

                            // Standard (Imperial) calculation
                            const speedOfSoundImperial = 1125; // ft/s
                            const wavelengthFeet = speedOfSoundImperial / freq;
                            const feet = Math.floor(wavelengthFeet);
                            const inches = ((wavelengthFeet - feet) * 12).toFixed(1);
                            const standardDisplay = `${feet}' ${inches}"`;

                            App.elements.wavelengthDisplay.textContent = `≈ ${standardDisplay} / ${metricDisplay}`;
                        } else {
                        App.elements.wavelengthDisplay.textContent = `—`;
                        }
                    },

                    updatePanDisplay(pan) {
                        const leftDisplay = App.elements.panDisplayLeft;
                        const rightDisplay = App.elements.panDisplayRight;
                        const button = App.elements.recenterPanBtn;
                        
                        // Ensure pan is a number
                        const panValue = parseFloat(pan);

                        if (panValue === 0) {
                            leftDisplay.textContent = '';
                            rightDisplay.textContent = '';
                            button.classList.add('bg-blue-600', 'text-white');
                            button.classList.remove('dark:bg-slate-600', 'bg-gray-200');
                        } else {
                            button.classList.remove('bg-blue-600', 'text-white');
                            button.classList.add('dark:bg-slate-600', 'bg-gray-200');
                            if (panValue < 0) {
                                leftDisplay.textContent = `${Math.round(Math.abs(panValue) * 100)}% L`;
                                rightDisplay.textContent = '';
                            } else {
                                leftDisplay.textContent = '';
                                rightDisplay.textContent = `R ${Math.round(panValue * 100)}%`;
                            }
                        }
                    },
                    
                    updateGainColor(db) {
                        const slider = App.elements.gainSlider;
                        const wrapper = App.elements.gainValueWrapper;
                        const colors = {
                            green: { slider: 'accent-green-600', wrapper: ['bg-green-50', 'text-green-600', 'dark:bg-green-900/50', 'dark:text-green-400'] },
                            yellow: { slider: 'accent-yellow-500', wrapper: ['bg-yellow-50', 'text-yellow-600', 'dark:bg-yellow-900/50', 'dark:text-yellow-400'] },
                            red: { slider: 'accent-red-600', wrapper: ['bg-red-50', 'text-red-600', 'dark:bg-red-900/50', 'dark:text-red-400'] }
                        };
                        slider.classList.remove(...Object.values(colors).map(c => c.slider));
                        wrapper.classList.remove(...Object.values(colors).flatMap(c => c.wrapper));
                        let activeColor = db < -5 ? colors.green : db <= 0 ? colors.yellow : colors.red;
                        slider.classList.add(activeColor.slider);
                        wrapper.classList.add(...activeColor.wrapper);
                    },

                    showFrequencyInput() {
                        App.elements.frequencyTextDisplay.classList.add('hidden');
                        App.elements.frequencyMainInput.classList.remove('hidden');
                        App.elements.frequencyMainInput.value = App.elements.freqValue.textContent;
                        App.elements.frequencyMainInput.focus();
                        App.elements.frequencyMainInput.select();
                    },

                    handleMainFreqInput() {
                        let freq = App.state.isProfessionalMode 
                            ? parseFloat(App.elements.frequencyMainInput.value)
                            : parseInt(App.elements.frequencyMainInput.value, 10);
                        freq = isNaN(freq) ? 440 : Math.max(5, Math.min(20000, freq));
                        
                        if (freq <= 250) App.elements.bassFreqSlider.value = freq;
                        else if (freq <= 4000) App.elements.midFreqSlider.value = freq;
                        else App.elements.trebleFreqSlider.value = freq;

                        this.updateFrequencyDisplay(freq);
                        App.audio.setFrequency(freq);

                        App.elements.frequencyTextDisplay.classList.remove('hidden');
                        App.elements.frequencyMainInput.classList.add('hidden');
                    },

                    showAudioOutputModal() {
                        App.elements.audioOutputModal.classList.remove('hidden');
                        App.audioOutput.updateStatus();
                        App.audioOutput.enumerateDevices();
                    },

                    closeAudioOutputModal() {
                        App.elements.audioOutputModal.classList.add('hidden');
                    },

                    applyAudioOutputSettings() {
                        App.audioOutput.updateDevice();
                        this.closeAudioOutputModal();
                    },

                    showDownloadModal() {
                        App.elements.downloadModal.classList.remove('hidden');
                        this.updateDownloadPreview();
                    },

                    closeDownloadModal() {
                        App.elements.downloadModal.classList.add('hidden');
                    },

                    updateDownloadPreview() {
                        const duration = App.elements.downloadDurationSelect.value;
                        const format = App.elements.downloadFormatSelect.value.toUpperCase();
                        const soundType = App.elements.soundTypeSelect.value;
                        const frequency = App.elements.freqValue.textContent;
                        
                        // Determine if this sound type uses frequency
                        const noiseTypes = ['white', 'pink', 'brown', 'blue', 'violet', 'gray'];
                        const specialTypes = ['sweep', 'warble', 'imd'];
                        const isNoise = noiseTypes.includes(soundType);
                        const isSpecial = specialTypes.includes(soundType);
                        
                        let toneDescription;
                        if (isNoise) {
                            // For noise types, just show the noise type
                            toneDescription = `${soundType.charAt(0).toUpperCase() + soundType.slice(1)} Noise`;
                        } else if (soundType === 'sweep') {
                            toneDescription = 'Frequency Sweep';
                        } else if (soundType === 'warble') {
                            toneDescription = 'Warble Tone';
                        } else if (soundType === 'imd') {
                            toneDescription = 'IMD Test (60Hz + 7kHz)';
                        } else {
                            // For regular tones, show frequency and type
                            toneDescription = `${frequency} Hz ${soundType.charAt(0).toUpperCase() + soundType.slice(1)}`;
                        }
                        
                        App.elements.downloadPreviewTone.textContent = toneDescription;
                        App.elements.downloadPreviewDuration.textContent = `${duration}s`;
                        App.elements.downloadPreviewFormat.textContent = format;
                    },

                    async startDownload() {
                        const duration = parseInt(App.elements.downloadDurationSelect.value);
                        const format = App.elements.downloadFormatSelect.value;
                        
                        // Update the download elements temporarily for the existing download function
                        App.elements.downloadDuration = { value: duration };
                        App.elements.downloadFormat = { value: format };
                        
                        this.closeDownloadModal();
                        await App.audio.download();
                    },

                    showPolarityWarning() {
                        App.elements.polarityWarningModal.classList.remove('hidden');
                    },

                    closePolarityWarning() {
                        App.elements.polarityWarningModal.classList.add('hidden');
                        App.state.polarityWarningShown = true;
                    },

                    handlePlayButtonClick() {
                        // Check for button abuse
                        if (App.state.playButtonAbused) return;
                        
                        App.state.playButtonClickCount++;
                        
                        // Reset counter after 3 seconds of no clicks
                        if (App.state.playButtonClickTimeout) {
                            clearTimeout(App.state.playButtonClickTimeout);
                        }
                        App.state.playButtonClickTimeout = setTimeout(() => {
                            App.state.playButtonClickCount = 0;
                        }, 3000);
                        
                        // Trigger abuse detection after 3 rapid clicks
                        if (App.state.playButtonClickCount >= 3) {
                            this.triggerPlayButtonAbuse();
                            return;
                        }
                        
                        // Normal play/stop functionality
                        App.audio.togglePlayback();
                    },

                    triggerPlayButtonAbuse() {
                        App.state.playButtonAbused = true;
                        App.state.playButtonClickCount = 0;
                        
                        // Hide the play button
                        App.elements.playStopButton.style.visibility = 'hidden';
                        
                        // Play error sound
                        this.playErrorSound();
                        
                        // Show abuse modal
                        setTimeout(() => {
                            App.elements.playAbuseModal.classList.remove('hidden');
                        }, 500);
                    },

                    playErrorSound() {
                        try {
                            const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            
                            // Create a harsh error sound using multiple tones
                            const playErrorTone = (frequency, startTime, duration, volume = 0.1) => {
                                const oscillator = audioContext.createOscillator();
                                const gainNode = audioContext.createGain();
                                
                                oscillator.connect(gainNode);
                                gainNode.connect(audioContext.destination);
                                
                                oscillator.frequency.setValueAtTime(frequency, startTime);
                                oscillator.type = 'square'; // Harsh square wave
                                
                                // Sharp attack and decay for error-like sound
                                gainNode.gain.setValueAtTime(0, startTime);
                                gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.01);
                                gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);
                                
                                oscillator.start(startTime);
                                oscillator.stop(startTime + duration);
                            };
                            
                            // Error sound pattern - descending harsh tones
                            const now = audioContext.currentTime;
                            playErrorTone(800, now, 0.15, 0.15);
                            playErrorTone(600, now + 0.1, 0.15, 0.15);
                            playErrorTone(400, now + 0.2, 0.2, 0.15);
                            
                        } catch (error) {
                            console.log('Audio context not available for error sound');
                        }
                    },

                    closePlayAbuseModal() {
                        App.elements.playAbuseModal.classList.add('hidden');
                        
                        // Restore the play button after a delay
                        setTimeout(() => {
                            App.elements.playStopButton.style.visibility = 'visible';
                            App.state.playButtonAbused = false;
                        }, 1000);
                    },
                },

                // --- 5. Converter Module ---
                converter: {
                    init() {
                        App.elements.combinedInput.addEventListener('input', (e) => this.handleInput(e.target.value));
                    },

                    gcd(a, b) {
                        return b === 0 ? a : this.gcd(b, a % b);
                    },

                    toFractional(decimalInches) {
                        const wholeInches = Math.floor(decimalInches);
                        const decimalPart = decimalInches - wholeInches;
                        
                        let numerator = Math.round(decimalPart * 64);
                        let finalWholeInches = wholeInches;

                        if (numerator === 64) {
                            finalWholeInches++;
                            return `${finalWholeInches}"`;
                        } else if (numerator === 0) {
                            return finalWholeInches === 0 ? '0"' : `${finalWholeInches}"`;
                        } else {
                            const divisor = this.gcd(numerator, 64);
                            const simplifiedNumerator = numerator / divisor;
                            const simplifiedDenominator = 64 / divisor;
                            const wholePartString = finalWholeInches > 0 ? `${finalWholeInches} ` : '';
                            return `${wholePartString}${simplifiedNumerator}/${simplifiedDenominator}"`;
                        }
                    },

                    convertInches(decimalInches) {
                        if (isNaN(decimalInches) || decimalInches === null || decimalInches < 0) {
                            return { fractional: '---', decimalInches: '---', feet: '---', millimeters: '---', centimeters: '---', meters: '---' };
                        }
                        const fractionalString = this.toFractional(decimalInches);
                        const feet = decimalInches / 12;
                        const millimeters = decimalInches * 25.4;
                        const centimeters = millimeters / 10;
                        const meters = centimeters / 100;
                        return {
                            fractional: fractionalString,
                            decimalInches: decimalInches.toFixed(3),
                            feet: feet.toFixed(2),
                            millimeters: millimeters.toFixed(2),
                            centimeters: centimeters.toFixed(2),
                            meters: meters.toFixed(2)
                        };
                    },
                    
                    updateResults(decimalValue) {
                        const results = this.convertInches(decimalValue);
                        const { elements } = App;
                        elements.fractionalResult.textContent = results.fractional;
                        elements.decimalInchResult.textContent = results.decimalInches;
                        elements.feetResult.textContent = results.feet;
                        elements.mmResult.textContent = results.millimeters;
                        elements.cmResult.textContent = results.centimeters;
                        elements.mResult.textContent = results.meters;
                    },

                    handleInput(value) {
                        value = value.trim().toLowerCase();
                        let decimalValue = NaN;

                        if (value === '') {
                            this.updateResults(NaN);
                            return;
                        }

                        const metricRegex = /([\d.]+)\s*(mm|cm|m)$/;
                        const metricMatch = value.match(metricRegex);

                        if (metricMatch) {
                            const number = parseFloat(metricMatch[1]);
                            const unit = metricMatch[2];
                            if (!isNaN(number)) {
                                if (unit === 'mm') decimalValue = number / 25.4;
                                else if (unit === 'cm') decimalValue = number / 2.54;
                                else if (unit === 'm') decimalValue = number / 0.0254;
                            }
                        } else if (value.includes('/')) {
                            const fractionalRegex = /^(?:(\d+)\s+)?(\d+)\/(\d+)$/;
                            const fractionalMatch = value.match(fractionalRegex);
                            if (fractionalMatch) {
                                const whole = parseInt(fractionalMatch[1] || '0');
                                const numerator = parseInt(fractionalMatch[2]);
                                const denominator = parseInt(fractionalMatch[3]);
                                if (denominator !== 0) decimalValue = whole + (numerator / denominator);
                            }
                        } else {
                            const parsedValue = parseFloat(value);
                            if (!isNaN(parsedValue)) decimalValue = parsedValue;
                        }

                        this.updateResults(decimalValue);
                    }
                },

                // --- 6. Audio Module ---
                audio: {
                    dbToLinear: db => Math.pow(10, db / 20),

                    downloadFile(blob, filename) {
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.style.display = 'none';
                        a.href = url;
                        a.download = filename;
                        document.body.appendChild(a);
                        a.click();
                        window.URL.revokeObjectURL(url);
                        document.body.removeChild(a);
                    },

                    bufferToWav(abuffer) {
                        const numOfChan = abuffer.numberOfChannels;
                        const sampleRate = abuffer.sampleRate;
                        const length = abuffer.length * numOfChan * 2 + 44;
                        const buffer = new ArrayBuffer(length);
                        const view = new DataView(buffer);
                        const channels = [];
                        let offset = 0;
                        let pos = 0;

                        const setUint16 = (data) => {
                            view.setUint16(pos, data, true);
                            pos += 2;
                        };
                        const setUint32 = (data) => {
                            view.setUint32(pos, data, true);
                            pos += 4;
                        };

                        setUint32(0x46464952); // "RIFF"
                        setUint32(length - 8); // file length - 8
                        setUint32(0x45564157); // "WAVE"
                        setUint32(0x20746d66); // "fmt " chunk
                        setUint32(16); // length = 16
                        setUint16(1); // PCM (uncompressed)
                        setUint16(numOfChan);
                        setUint32(sampleRate);
                        setUint32(sampleRate * 2 * numOfChan); // avg. bytes/sec
                        setUint16(numOfChan * 2); // block-align
                        setUint16(16); // 16-bit
                        setUint32(0x61746164); // "data" - chunk
                        setUint32(length - pos - 4); // chunk length

                        for (let i = 0; i < abuffer.numberOfChannels; i++) {
                            channels.push(abuffer.getChannelData(i));
                        }

                        while (pos < length) {
                            for (let i = 0; i < numOfChan; i++) {
                                if (offset >= abuffer.length) break;
                                let sample = Math.max(-1, Math.min(1, channels[i][offset]));
                                sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0;
                                view.setInt16(pos, sample, true);
                                pos += 2;
                            }
                            if (offset >= abuffer.length) break;
                            offset++;
                        }

                        return buffer;
                    },

                    createOfflineSource(ctx, soundType) {
                        const elements = App.elements;
                        const isSweep = soundType === 'sweep';
                        const isWarble = soundType === 'warble';
                        const isIMD = soundType === 'imd';

                        if (isIMD) {
                            const osc1 = ctx.createOscillator();
                            const osc2 = ctx.createOscillator();
                            osc1.frequency.value = 60;
                            osc2.frequency.value = 7000;
                            osc1.start(0);
                            osc2.start(0);
                            return [osc1, osc2];
                        }

                        const sourceNode = ctx.createOscillator();
                        sourceNode.type = isSweep || isWarble ? 'sine' : soundType;

                        if (isSweep) {
                            const start = parseFloat(elements.startFreq.value) || 20;
                            let end = parseFloat(elements.endFreq.value) || 1000;
                            const time = parseFloat(elements.sweepTime.value) || 5;
                            const type = elements.sweepType.value;
                            sourceNode.frequency.setValueAtTime(start, 0);
                            if (type === 'logarithmic') {
                                if (end <= 0) end = 1;
                                sourceNode.frequency.exponentialRampToValueAtTime(end, ctx.currentTime + time);
                            } else {
                                sourceNode.frequency.linearRampToValueAtTime(end, ctx.currentTime + time);
                            }
                        } else if (isWarble) {
                            const centerFreq = parseFloat(elements.warbleCenterFreq.value) || 1000;
                            const depth = parseFloat(elements.warbleDepth.value) || 50;
                            const speed = parseFloat(elements.warbleSpeed.value) || 5;
                            const lfo = ctx.createOscillator();
                            lfo.frequency.value = speed;
                            const lfoGain = ctx.createGain();
                            lfoGain.gain.value = depth;
                            lfo.connect(lfoGain).connect(sourceNode.frequency);
                            lfo.start(0);
                            sourceNode.frequency.setValueAtTime(centerFreq, 0);
                        } else {
                            const currentFreq = parseFloat(elements.freqValue.textContent);
                            sourceNode.frequency.setValueAtTime(currentFreq, 0);
                        }
                        sourceNode.start(0);
                        return sourceNode;
                    },

                    async download() {
                        const btn = App.elements.downloadButton;
                        btn.disabled = true;
                        
                        const format = App.elements.downloadFormat.value;
                        btn.textContent = `Rendering ${format.toUpperCase()}...`;

                        try {
                            const soundType = App.elements.soundTypeSelect.value;
                            const duration = parseInt(App.elements.downloadDuration.value, 10);
                            const sampleRate = 44100;
                            const gainValue = App.elements.gainSlider.value;
                            const panValue = parseFloat(App.elements.panSlider.value);
                            const isNoise = ['white', 'pink', 'brown', 'blue', 'violet', 'gray'].includes(soundType);

                            const offlineCtx = new OfflineAudioContext(2, sampleRate * duration, sampleRate);
                            const pannerNode = offlineCtx.createStereoPanner();
                            pannerNode.pan.setValueAtTime(panValue, 0);
                            pannerNode.connect(offlineCtx.destination);

                            const gainNode = offlineCtx.createGain();
                            gainNode.gain.setValueAtTime(this.dbToLinear(gainValue), 0);
                            gainNode.connect(pannerNode);

                            let sourceNode;
                            if (isNoise) {
                                await offlineCtx.audioWorklet.addModule(App.state.noiseProcessorUrl);
                                sourceNode = new AudioWorkletNode(offlineCtx, 'noise-processor');
                                sourceNode.port.postMessage({ type: soundType });
                            } else {
                                sourceNode = this.createOfflineSource(offlineCtx, soundType);
                            }

                            if (Array.isArray(sourceNode)) {
                                sourceNode.forEach(node => node.connect(gainNode));
                            } else {
                                sourceNode.connect(gainNode);
                            }

                            const renderedBuffer = await offlineCtx.startRendering();
                            const baseFilename = `${soundType}_${App.elements.freqValue.textContent}Hz_${duration}s`.replace(/ /g, '_');

                            if (format === 'wav') {
                                const wav = this.bufferToWav(renderedBuffer);
                                this.downloadFile(new Blob([wav], { type: 'audio/wav' }), `${baseFilename}.wav`);
                            } else if (format === 'mp3') {
                                const left = renderedBuffer.getChannelData(0);
                                const right = renderedBuffer.getChannelData(1);
                                const mp3encoder = new lamejs.Mp3Encoder(2, sampleRate, 128);
                                const samplesLeft = new Int16Array(left.length);
                                const samplesRight = new Int16Array(right.length);

                                for (let i = 0; i < left.length; i++) {
                                    samplesLeft[i] = left[i] * 32767.5;
                                    samplesRight[i] = right[i] * 32767.5;
                                }
                                
                                const mp3Data = [];
                                const blockSize = 1152;
                                for (let i = 0; i < samplesLeft.length; i += blockSize) {
                                    const leftChunk = samplesLeft.subarray(i, i + blockSize);
                                    const rightChunk = samplesRight.subarray(i, i + blockSize);
                                    const mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
                                    if (mp3buf.length > 0) mp3Data.push(mp3buf);
                                }
                                const mp3buf = mp3encoder.flush();
                                if (mp3buf.length > 0) mp3Data.push(mp3buf);
                                this.downloadFile(new Blob(mp3Data, { type: 'audio/mpeg' }), `${baseFilename}.mp3`);
                            } else if (format === 'flac') {
                                const left = renderedBuffer.getChannelData(0);
                                const right = renderedBuffer.getChannelData(1);
                                const samples = [new Int32Array(left.length), new Int32Array(right.length)];
                                for (let i = 0; i < left.length; i++) {
                                    samples[0][i] = Math.floor(left[i] * 2147483647);
                                    samples[1][i] = Math.floor(right[i] * 2147483647);
                                }
                                const flac_encoder = Flac.create_libflac_encoder(sampleRate, 2, 24, 5, 0);
                                if(flac_encoder !== 0) {
                                    const flac_data = Flac.encode_libflac_encoder(flac_encoder, samples[0], samples[1]);
                                    this.downloadFile(new Blob([flac_data], { type: 'audio/flac' }), `${baseFilename}.flac`);
                                    Flac.FLAC__stream_encoder_delete(flac_encoder);
                                } else {
                                    alert('Failed to create FLAC encoder.');
                                }
                            }

                        } catch (error) {
                            console.error('Failed to download audio:', error);
                            alert('Sorry, there was an error generating the audio file.');
                        } finally {
                            btn.disabled = false;
                            btn.textContent = 'Download Snippet';
                        }
                    },

                    createNoiseProcessor() {
                        const noiseProcessorCode = `
                            class NoiseProcessor extends AudioWorkletProcessor {
                                constructor() {
                                    super();
                                    this.pink = { b0: 0, b1: 0, b2: 0, b3: 0, b4: 0, b5: 0, b6: 0 };
                                    this.brownLastOut = 0.0;
                                    this.blueLastOut = 0.0;
                                    this.violetLastOut = 0.0;
                                    this.grayLastOut = 0.0;
                                    this.noiseType = 'white';
                                    this.port.onmessage = e => { if (e.data.type) this.noiseType = e.data.type; };
                                }
                                process(inputs, outputs) {
                                    const out = outputs[0][0];
                                    for (let i = 0; i < out.length; i++) {
                                        const white = Math.random() * 2 - 1;
                                        if (this.noiseType === 'white') out[i] = white;
                                        else if (this.noiseType === 'pink') {
                                            this.pink.b0 = 0.99886 * this.pink.b0 + white * 0.0555179; this.pink.b1 = 0.99332 * this.pink.b1 + white * 0.0750759; this.pink.b2 = 0.96900 * this.pink.b2 + white * 0.1538520; this.pink.b3 = 0.86650 * this.pink.b3 + white * 0.3104856; this.pink.b4 = 0.55000 * this.pink.b4 + white * 0.5329522; this.pink.b5 = -0.7616 * this.pink.b5 - white * 0.0168980;
                                            out[i] = (this.pink.b0 + this.pink.b1 + this.pink.b2 + this.pink.b3 + this.pink.b4 + this.pink.b5 + this.pink.b6 + white * 0.5362) * 0.11;
                                            this.pink.b6 = white * 0.115926;
                                        } else if (this.noiseType === 'brown') {
                                            this.brownLastOut = (this.brownLastOut + (0.02 * white)) / 1.02; out[i] = this.brownLastOut * 3.5;
                                        } else if (this.noiseType === 'blue') {
                                            // Blue noise: +3dB/octave (differentiator)
                                            out[i] = (white - this.blueLastOut) * 0.5;
                                            this.blueLastOut = white;
                                        } else if (this.noiseType === 'violet') {
                                            // Violet noise: +6dB/octave (double differentiator)
                                            const current = white - this.violetLastOut;
                                            out[i] = current * 2.0;
                                            this.violetLastOut = white;
                                        } else if (this.noiseType === 'gray') {
                                            // Gray noise: psychoacoustic equal loudness curve approximation
                                            // Simple approximation using multiple frequency bands
                                            if (!this.grayFilters) {
                                                this.grayFilters = { low: 0, mid: 0, high: 0 };
                                            }
                                            // Low frequency emphasis
                                            this.grayFilters.low = this.grayFilters.low * 0.99 + white * 0.01;
                                            // Mid frequency
                                            this.grayFilters.mid = this.grayFilters.mid * 0.95 + white * 0.05;
                                            // High frequency de-emphasis
                                            this.grayFilters.high = this.grayFilters.high * 0.85 + white * 0.15;
                                            
                                            out[i] = (this.grayFilters.low * 0.3 + this.grayFilters.mid * 1.0 + this.grayFilters.high * 0.1) * 0.7;
                                        }
                                    }
                                    return true;
                                }
                            }
                            registerProcessor('noise-processor', NoiseProcessor);`;
                        const blob = new Blob([noiseProcessorCode], { type: 'application/javascript' });
                        App.state.noiseProcessorUrl = URL.createObjectURL(blob);
                    },

                    async play() {
                        if (App.state.isPlaying) return;
                        const state = App.state;
                        const elements = App.elements;

                        state.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        state.visualizerCtx = elements.visualizerCanvas.getContext('2d');
                        
                        state.analyser = state.audioContext.createAnalyser();
                        state.analyser.fftSize = 8192;
                        state.analyser.minDecibels = -90;
                        state.analyser.maxDecibels = -10;
                        state.analyser.smoothingTimeConstant = 0.85;

                        state.gainNode = state.audioContext.createGain();
                        state.gainNode.gain.setValueAtTime(this.dbToLinear(elements.gainSlider.value), state.audioContext.currentTime);
                        
                        state.pannerNode = state.audioContext.createStereoPanner();
                        state.pannerNode.pan.setValueAtTime(parseFloat(elements.panSlider.value), state.audioContext.currentTime);

                        const splitter = state.audioContext.createChannelSplitter(2);
                        const merger = state.audioContext.createChannelMerger(2);
                        state.phaseInvertNode = state.audioContext.createGain();
                        state.phaseInvertNode.gain.value = App.state.isPhaseInverted ? -1 : 1;

                        const soundType = elements.soundTypeSelect.value;
                        const isNoise = ['white', 'pink', 'brown', 'blue', 'violet', 'gray'].includes(soundType);
                        
                        if (isNoise) {
                            await state.audioContext.audioWorklet.addModule(state.noiseProcessorUrl);
                            state.sourceNode = new AudioWorkletNode(state.audioContext, 'noise-processor');
                            state.sourceNode.port.postMessage({ type: soundType });
                        } else {
                            this.createToneSource(soundType);
                        }

                        if (Array.isArray(state.sourceNode)) {
                            state.sourceNode.forEach(node => node.connect(state.gainNode));
                        } else {
                            state.sourceNode.connect(state.gainNode);
                        }
                        state.gainNode.connect(state.pannerNode);
                        state.pannerNode.connect(splitter);
                        splitter.connect(merger, 0, 0);
                        splitter.connect(state.phaseInvertNode, 1, 0);
                        state.phaseInvertNode.connect(merger, 0, 1);
                        merger.connect(state.audioContext.destination);
                        state.gainNode.connect(state.analyser);

                        state.isPlaying = true;
                        App.ui.updatePlayButton(true);
                        App.visualizer.start();
                    },

                    createToneSource(soundType) {
                        const state = App.state;
                        const elements = App.elements;
                        const isSweep = soundType === 'sweep';
                        const isWarble = soundType === 'warble';
                        const isIMD = soundType === 'imd';

                        if (isIMD) {
                            const osc1 = state.audioContext.createOscillator();
                            const osc2 = state.audioContext.createOscillator();
                            osc1.frequency.value = 60;
                            osc2.frequency.value = 7000;
                            osc1.start(); osc2.start();
                            state.sourceNode = [osc1, osc2];
                            return;
                        }

                        state.sourceNode = state.audioContext.createOscillator();
                        state.sourceNode.type = isSweep || isWarble ? 'sine' : soundType;
                        
                        if (isSweep) {
                            const start = parseFloat(elements.startFreq.value) || 20;
                            let end = parseFloat(elements.endFreq.value) || 1000;
                            const time = parseFloat(elements.sweepTime.value) || 5;
                            const type = elements.sweepType.value;
                            
                            state.sourceNode.frequency.setValueAtTime(start, state.audioContext.currentTime);
                            if (type === 'logarithmic') {
                                if (end <= 0) end = 1;
                                state.sourceNode.frequency.exponentialRampToValueAtTime(end, state.audioContext.currentTime + time);
                            } else {
                                state.sourceNode.frequency.linearRampToValueAtTime(end, state.audioContext.currentTime + time);
                            }
                            state.sweepTimeoutId = setTimeout(() => this.stop(), time * 1000);
                        } else if (isWarble) {
                            const centerFreq = parseFloat(elements.warbleCenterFreq.value) || 1000;
                            const depth = parseFloat(elements.warbleDepth.value) || 50;
                            const speed = parseFloat(elements.warbleSpeed.value) || 5;

                            const lfo = state.audioContext.createOscillator();
                            lfo.frequency.value = speed;
                            const lfoGain = state.audioContext.createGain();
                            lfoGain.gain.value = depth;
                            lfo.connect(lfoGain).connect(state.sourceNode.frequency);
                            lfo.start();
                            state.sourceNode.frequency.setValueAtTime(centerFreq, state.audioContext.currentTime);
                        } else {
                            const currentFreq = parseFloat(elements.freqValue.textContent);
                            state.sourceNode.frequency.setValueAtTime(currentFreq, state.audioContext.currentTime);
                        }
                        state.sourceNode.start();
                    },

                    stop() {
                        const state = App.state;
                        if (!state.isPlaying) return;
                        
                        App.visualizer.stop();
                        App.visualizer.resetVolumeVisualizer(); // Reset volume bars with fade-out
                        if (state.sweepTimeoutId) clearTimeout(state.sweepTimeoutId);
                        state.sweepTimeoutId = null;

                        if (Array.isArray(state.sourceNode)) state.sourceNode.forEach(node => node.stop());
                        else if (state.sourceNode?.stop) state.sourceNode.stop();
                        
                        if (state.sourceNode) {
                            if (Array.isArray(state.sourceNode)) state.sourceNode.forEach(node => node.disconnect());
                            else state.sourceNode.disconnect();
                        }

                        if (state.analyser) state.analyser.disconnect();
                        if (state.pannerNode) state.pannerNode.disconnect();
                        if (state.gainNode) state.gainNode.disconnect();
                        if (state.audioContext) state.audioContext.close();
                        
                        
                        state.isPlaying = false;
                        App.ui.updatePlayButton(false);
                        const staticFreq = parseFloat(App.elements.freqValue.textContent);
                        App.ui.updateFrequencyDisplay(staticFreq);
                    },

                    togglePlayback() {
                        if (App.state.isPlaying) this.stop();
                        else this.play();
                    },

                    setFrequency(freq) {
                        if (App.state.isPlaying && App.state.sourceNode?.frequency) {
                            App.state.sourceNode.frequency.setValueAtTime(freq, App.state.audioContext.currentTime);
                        }
                    },

                    setGain(db) {
                        if (App.state.isPlaying && App.state.gainNode) {
                            App.state.gainNode.gain.setTargetAtTime(this.dbToLinear(db), App.state.audioContext.currentTime, 0.01);
                        }
                    },

                    setPan(pan) {
                        if (App.state.isPlaying && App.state.pannerNode) {
                            App.state.pannerNode.pan.setTargetAtTime(pan, App.state.audioContext.currentTime, 0.01);
                        }
                    },

                    setPhase(inverted) {
                        const { isPlaying, phaseInvertNode, audioContext } = App.state;
                        if (isPlaying && phaseInvertNode) {
                            phaseInvertNode.gain.setTargetAtTime(inverted ? -1 : 1, audioContext.currentTime, 0.01);
                        }
                    },
                },

                // --- 6. Visualizer Module ---
                visualizer: {
                    start() {
                        // Initialize the visualizer when starting
                        this.initializeVisualizer();
                        this.loop();
                    },
                    stop() {
                        if (App.state.animationFrameId) {
                            cancelAnimationFrame(App.state.animationFrameId);
                            App.state.animationFrameId = null;
                        }
                    },
                    loop() {
                        if (!App.state.isPlaying) return;
                        const state = App.state;
                        const mode = state.currentViewMode;
                        const soundType = App.elements.soundTypeSelect.value;

                        if (mode > 0) { // Any mode other than number display
                            // Use the new audio tools visualizer
                            this.analyzeAndVisualize(state.analyser);
                        }
                        
                        // Update volume visualizer
                        this.updateVolumeVisualizer(state.analyser);
                        
                        // Only update frequency from live detection for dynamic tones
                        if (soundType === 'sweep' || soundType === 'warble') {
                           this.updateLiveFrequency();
                        }

                        state.animationFrameId = requestAnimationFrame(() => this.loop());
                    },

                    updateLiveFrequency() {
                        const { analyser, audioContext } = App.state;
                        const freqBufferLength = analyser.frequencyBinCount;
                        const dataArray = new Uint8Array(freqBufferLength);
                        analyser.getByteFrequencyData(dataArray);

                        let maxVal = -Infinity, maxIndex = -1;
                        for (let i = 0; i < freqBufferLength; i++) {
                            if (dataArray[i] > maxVal) {
                                maxVal = dataArray[i];
                                maxIndex = i;
                            }
                        }
                        const detectedFreq = maxIndex * audioContext.sampleRate / analyser.fftSize;
                        if (detectedFreq > 0) {
                           App.ui.updateFrequencyDisplay(detectedFreq);
                        }
                    },

                    drawSpectrogram(dataArray) {
                        const { visualizerCanvas: canvas, visualizerCtx: ctx } = { ...App.elements, ...App.state };
                        const { height, width } = canvas;
                        ctx.drawImage(canvas, -1, 0, width, height);
                        const bufferLength = App.state.analyser.frequencyBinCount;
                        for (let i = 0; i < bufferLength; i++) {
                            const value = dataArray[i];
                            const percent = value / 255;
                            const y = height - (i / bufferLength) * height;
                            const hue = 240 - (percent * 240);
                            ctx.fillStyle = `hsl(${hue}, 100%, 50%)`;
                            ctx.fillRect(width - 1, y, 1, 1);
                        }
                    },
                    
                    drawWaveform(dataArray) {
                        const { visualizerCanvas: canvas, visualizerCtx: ctx } = { ...App.elements, ...App.state };
                        const { height, width } = canvas;
                        const bufferLength = App.state.analyser.fftSize;
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(0, 0, width, height);
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = document.documentElement.classList.contains('dark') ? '#60a5fa' : '#2563eb';
                        ctx.beginPath();
                        const sliceWidth = width * 1.0 / bufferLength;
                        let x = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            const v = dataArray[i] / 128.0;
                            const y = v * height / 2;
                            if (i === 0) ctx.moveTo(x, y);
                            else ctx.lineTo(x, y);
                            x += sliceWidth;
                        }
                        ctx.lineTo(canvas.width, canvas.height / 2);
                        ctx.stroke();
                    },

                    /**
                     * Audio Tools Spectrum Visualizer
                     * Dual-mode visualizer with waveform and colorful FFT spectrum
                     */
                    
                    // Initialize visualizer contexts
                    initializeVisualizer() {
                        const canvas = App.elements.visualizerCanvas;
                        if (canvas) {
                            App.state.visualizerCtx = canvas.getContext('2d');
                            // Wait a moment for DOM to settle before clearing canvas
                            setTimeout(() => {
                                this.clearCanvas();
                            }, 10);
                        }
                    },

                    // Clear canvas with dark background
                    clearCanvas() {
                        const canvas = App.elements.visualizerCanvas;
                        const ctx = App.state.visualizerCtx;
                        if (ctx && canvas) {
                            // Ensure canvas has proper dimensions
                            const rect = canvas.getBoundingClientRect();
                            if (rect.width > 0 && rect.height > 0) {
                                canvas.width = rect.width;
                                canvas.height = rect.height;
                                ctx.fillStyle = '#171717';
                                ctx.fillRect(0, 0, canvas.width, canvas.height);
                            }
                        }
                    },

                    // Waveform/Oscilloscope Display
                    drawScope(data) {
                        const canvas = App.elements.visualizerCanvas;
                        const ctx = App.state.visualizerCtx;
                        if (!ctx) return;
                        
                        // Semi-transparent overlay for persistence effect
                        ctx.fillStyle = 'rgba(23,23,23,0.1)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Draw waveform
                        ctx.lineWidth = 2;
                        ctx.strokeStyle = '#3b82f6'; // Blue color
                        ctx.beginPath();
                        
                        const sliceWidth = canvas.width * 1.0 / data.length;
                        let x = 0;
                        
                        for (let i = 0; i < data.length; i++) {
                            const v = data[i] * 0.5 + 0.5; // Normalize to 0-1
                            const y = v * canvas.height;
                            
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                            x += sliceWidth;
                        }
                        
                        ctx.stroke();
                    },

                    // FFT Spectrum Display (Colorful bars)
                    drawFFT(data) {
                        const canvas = App.elements.visualizerCanvas;
                        const ctx = App.state.visualizerCtx;
                        if (!ctx) return;
                        
                        // Semi-transparent overlay for persistence effect
                        ctx.fillStyle = 'rgba(23,23,23,0.1)';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Calculate bar width
                        const barWidth = (canvas.width / (data.length * 0.8));
                        let x = 0;
                        
                        // Draw frequency bars
                        for (let i = 0; i < data.length; i++) {
                            // Convert dB to bar height (assuming data is in dB, typically -140 to 0)
                            const barHeight = (data[i] + 140) * (canvas.height / 120);
                            
                            // Create color based on frequency/amplitude
                            const hue = 120 - (barHeight * 1.5); // Green to red gradient
                            ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                            
                            // Draw bar from bottom up
                            ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                            x += barWidth;
                        }
                    },

                    // Complete analyzer that draws both visualizations
                    analyzeAndVisualize(analyser) {
                        if (!analyser) return;
                        
                        const mode = App.state.currentViewMode;
                        
                        if (mode === 2) { // Spectrogram mode - keep existing
                            const dataArray = new Uint8Array(analyser.frequencyBinCount);
                            analyser.getByteFrequencyData(dataArray);
                            this.drawSpectrogram(dataArray);
                        } else if (mode === 3) { // Waveform mode - use new scope display
                            const timeDomainData = new Float32Array(analyser.fftSize);
                            analyser.getFloatTimeDomainData(timeDomainData);
                            this.drawScope(timeDomainData);
                        } else if (mode === 1) { // FFT mode - use new colorful bars
                            const frequencyData = new Float32Array(analyser.frequencyBinCount);
                            analyser.getFloatFrequencyData(frequencyData);
                            this.drawFFT(frequencyData);
                        }
                    },

                    // Volume Visualizer Update Function
                    updateVolumeVisualizer(analyser) {
                        if (!analyser || !App.elements.volumeBars) return;
                        
                        // Get time domain data for more accurate volume measurement
                        const bufferLength = analyser.fftSize;
                        const dataArray = new Float32Array(bufferLength);
                        analyser.getFloatTimeDomainData(dataArray);
                        
                        // Calculate RMS (Root Mean Square) for overall volume
                        let sum = 0;
                        for (let i = 0; i < bufferLength; i++) {
                            sum += dataArray[i] * dataArray[i];
                        }
                        const rms = Math.sqrt(sum / bufferLength);
                        
                        // Convert to dB and then to percentage
                        const db = rms > 0 ? 20 * Math.log10(rms) : -Infinity;
                        const normalizedDb = Math.max(-60, Math.min(0, db)); // Clamp between -60dB and 0dB
                        const percentage = ((normalizedDb + 60) / 60) * 100; // Convert to 0-100%
                        
                        // Add some variation for stereo effect (simulate L/R channels)
                        const panValue = parseFloat(App.elements.panSlider.value) || 0;
                        const leftPercent = Math.max(0, Math.min(100, percentage * (1 - Math.max(0, panValue))));
                        const rightPercent = Math.max(0, Math.min(100, percentage * (1 + Math.min(0, panValue))));
                        
                        // Update the volume bars with smooth animation (horizontal bars use width instead of height)
                        if (App.elements.volumeBars.length >= 2) {
                            App.elements.volumeBars[0].style.width = `${leftPercent}%`;
                            App.elements.volumeBars[1].style.width = `${rightPercent}%`;
                        }
                        
                        // Update LEDs with three-stage system: yellow for high volume, red solid for clipping, red pulsing for heavy clipping
                        // Convert -5.1 dB to percentage: ((-5.1 + 60) / 60) * 100 = 91.5%
                        const yellowThreshold = 91.5; // Yellow LED threshold (-5.1 dB)
                        const redThreshold = 95;    // Red LED threshold (near clipping)
                        const pulseThreshold = 98;  // Heavy clipping threshold (pulsing red)
                        
                        // Left channel LEDs
                        if (App.elements.volumeLedLeftYellow) {
                            if (leftPercent > yellowThreshold) {
                                App.elements.volumeLedLeftYellow.className = 'w-2 h-2 rounded-full border border-yellow-400 ml-1 transition-all duration-200 led-on-yellow';
                            } else {
                                App.elements.volumeLedLeftYellow.className = 'w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200';
                            }
                        }
                        
                        if (App.elements.volumeLedLeftRed) {
                            if (leftPercent > pulseThreshold) {
                                // Heavy clipping - pulsing red
                                App.elements.volumeLedLeftRed.className = 'w-2 h-2 rounded-full border border-red-400 ml-1 transition-all duration-200 led-on-red-pulse';
                            } else if (leftPercent > redThreshold) {
                                // Near clipping - solid red
                                App.elements.volumeLedLeftRed.className = 'w-2 h-2 rounded-full border border-red-400 ml-1 transition-all duration-200 led-on-red-solid';
                            } else {
                                App.elements.volumeLedLeftRed.className = 'w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200';
                            }
                        }
                        
                        // Right channel LEDs
                        if (App.elements.volumeLedRightYellow) {
                            if (rightPercent > yellowThreshold) {
                                App.elements.volumeLedRightYellow.className = 'w-2 h-2 rounded-full border border-yellow-400 ml-1 transition-all duration-200 led-on-yellow';
                            } else {
                                App.elements.volumeLedRightYellow.className = 'w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200';
                            }
                        }
                        
                        if (App.elements.volumeLedRightRed) {
                            if (rightPercent > pulseThreshold) {
                                // Heavy clipping - pulsing red
                                App.elements.volumeLedRightRed.className = 'w-2 h-2 rounded-full border border-red-400 ml-1 transition-all duration-200 led-on-red-pulse';
                            } else if (rightPercent > redThreshold) {
                                // Near clipping - solid red
                                App.elements.volumeLedRightRed.className = 'w-2 h-2 rounded-full border border-red-400 ml-1 transition-all duration-200 led-on-red-solid';
                            } else {
                                App.elements.volumeLedRightRed.className = 'w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200';
                            }
                        }
                    },

                    // Reset Volume Visualizer with fade-out effect
                    resetVolumeVisualizer() {
                        if (App.elements.volumeBars && App.elements.volumeBars.length >= 2) {
                            // Set bars to 0% width with smooth transition (CSS handles the animation)
                            App.elements.volumeBars[0].style.width = '0%';
                            App.elements.volumeBars[1].style.width = '0%';
                        }
                        
                        // Reset all LEDs to off state
                        if (App.elements.volumeLedLeftYellow) {
                            App.elements.volumeLedLeftYellow.className = 'w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200';
                        }
                        if (App.elements.volumeLedLeftRed) {
                            App.elements.volumeLedLeftRed.className = 'w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200';
                        }
                        if (App.elements.volumeLedRightYellow) {
                            App.elements.volumeLedRightYellow.className = 'w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200';
                        }
                        if (App.elements.volumeLedRightRed) {
                            App.elements.volumeLedRightRed.className = 'w-2 h-2 rounded-full bg-gray-600 dark:bg-gray-700 border border-gray-500 ml-1 transition-all duration-200';
                        }
                    }

                },

                // --- 7. Polarity Checker Module ---
                polarityChecker: {
                    isRunning: false,
                    audioContext: null,
                    microphoneStream: null,
                    analyser: null,
                    timeDomainData: null,
                    poppingInterval: null,
                    analysisInterval: null,
                    pulseBuffer: null,
                    popSpeed: 400, // milliseconds
                    gain: 0.3, // 0.0 to 1.0
                    isDragging: false,

                    createPulseBuffer(context) {
                        // Create a single-cycle 100Hz sawtooth wave buffer for consistent polarity testing
                        const frequency = 100;
                        const frameCount = context.sampleRate / frequency;
                        const buffer = context.createBuffer(1, frameCount, context.sampleRate);
                        const data = buffer.getChannelData(0);
                        for (let i = 0; i < frameCount; i++) {
                            data[i] = (2 * (i / frameCount)) - 1;
                        }
                        return buffer;
                    },

                    playPulse() {
                        if (!this.audioContext || !this.pulseBuffer) return;
                        
                        const bufferSource = this.audioContext.createBufferSource();
                        bufferSource.buffer = this.pulseBuffer;
                        
                        // Add a gain node with user-controlled volume
                        const gainNode = this.audioContext.createGain();
                        gainNode.gain.value = this.gain;
                        
                        bufferSource.connect(gainNode);
                        gainNode.connect(this.audioContext.destination);
                        bufferSource.start();
                    },

                    analyzePolarity() {
                        if (!this.analyser || !this.timeDomainData) return;
                        
                        this.analyser.getFloatTimeDomainData(this.timeDomainData);
                        let maxVal = 0;
                        let minVal = 0;
                        
                        // Find the maximum positive and minimum negative peaks
                        for (let i = 0; i < this.timeDomainData.length; i++) {
                            if (this.timeDomainData[i] > maxVal) {
                                maxVal = this.timeDomainData[i];
                            }
                            if (this.timeDomainData[i] < minVal) {
                                minVal = this.timeDomainData[i];
                            }
                        }
                        
                        // Use the peak with the larger absolute value for polarity detection
                        const usePositivePeak = Math.abs(maxVal) > Math.abs(minVal);
                        const peakValue = usePositivePeak ? maxVal : minVal;
                        const threshold = 0.005; // Lower threshold for continuous detection
                        
                        // Update display with current polarity status
                        if (Math.abs(peakValue) > threshold) {
                            const isInPhase = peakValue > 0;
                            this.displayPolarityResult(isInPhase);
                        }
                    },

                    displayPolarityResult(isInPhase) {
                        const resultDiv = App.elements.polarityResult;
                        const inPhaseLed = App.elements.inPhaseLed;
                        const outOfPhaseLed = App.elements.outOfPhaseLed;
                        
                        if (isInPhase === null || isInPhase === undefined) {
                            // Reset display and LEDs
                            resultDiv.innerHTML = `<div class="text-2xl font-bold text-gray-400">READY</div>`;
                            inPhaseLed.className = 'w-3 h-3 rounded-full border border-green-400 bg-gray-600 transition-all duration-200';
                            outOfPhaseLed.className = 'w-3 h-3 rounded-full border border-red-400 bg-gray-600 transition-all duration-200';
                            return;
                        }
                        
                        if (isInPhase) {
                            // In Phase - light up green LED, turn off red LED
                            resultDiv.innerHTML = `<div class="text-2xl font-bold text-green-400">IN PHASE</div>`;
                            inPhaseLed.className = 'w-3 h-3 rounded-full border border-green-400 transition-all duration-200 led-on-green';
                            outOfPhaseLed.className = 'w-3 h-3 rounded-full border border-red-400 bg-gray-600 transition-all duration-200';
                        } else {
                            // Out of Phase - light up red LED, turn off green LED
                            resultDiv.innerHTML = `<div class="text-2xl font-bold text-red-400">OUT OF PHASE</div>`;
                            inPhaseLed.className = 'w-3 h-3 rounded-full border border-green-400 bg-gray-600 transition-all duration-200';
                            outOfPhaseLed.className = 'w-3 h-3 rounded-full border border-red-400 transition-all duration-200 led-on-red';
                        }
                    },

                    async startTesting() {
                        if (this.isRunning) return;
                        
                        try {
                            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            if (this.audioContext.state === 'suspended') {
                                await this.audioContext.resume();
                            }

                            this.pulseBuffer = this.createPulseBuffer(this.audioContext);
                            this.microphoneStream = await navigator.mediaDevices.getUserMedia({
                                audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                            });
                            
                            const source = this.audioContext.createMediaStreamSource(this.microphoneStream);
                            this.analyser = this.audioContext.createAnalyser();
                            this.analyser.fftSize = 2048;
                            this.analyser.smoothingTimeConstant = 0.3;
                            this.timeDomainData = new Float32Array(this.analyser.fftSize);
                            source.connect(this.analyser);

                            this.isRunning = true;
                            
                            // Update toggle switch and status
                            App.elements.polarityTestBtn.checked = true;
                            App.elements.powerStatus.textContent = 'ON';
                            App.elements.powerStatus.classList.remove('text-gray-400');
                            App.elements.powerStatus.classList.add('text-green-400');
                            
                            this.displayPolarityResult(null);

                            // Start continuous popping with user-controlled speed
                            this.poppingInterval = setInterval(() => this.playPulse(), this.popSpeed);
                            
                            // Start continuous analysis every 100ms for real-time updates
                            this.analysisInterval = setInterval(() => this.analyzePolarity(), 100);

                        } catch (err) {
                            alert(`Error: ${err.message}`);
                            this.stopTesting();
                        }
                    },

                    stopTesting() {
                        if (!this.isRunning) return;

                        this.isRunning = false;
                        
                        if (this.poppingInterval) {
                            clearInterval(this.poppingInterval);
                            this.poppingInterval = null;
                        }
                        
                        if (this.analysisInterval) {
                            clearInterval(this.analysisInterval);
                            this.analysisInterval = null;
                        }
                        
                        if (this.microphoneStream) {
                            this.microphoneStream.getTracks().forEach(track => track.stop());
                            this.microphoneStream = null;
                        }
                        
                        if (this.audioContext) {
                            this.audioContext.close();
                            this.audioContext = null;
                        }

                        this.analyser = null;
                        this.timeDomainData = null;
                        this.pulseBuffer = null;
                        
                        // Reset toggle switch and status
                        App.elements.polarityTestBtn.checked = false;
                        App.elements.powerStatus.textContent = 'OFF';
                        App.elements.powerStatus.classList.remove('text-green-400');
                        App.elements.powerStatus.classList.add('text-gray-400');
                        
                        // Reset display
                        this.displayPolarityResult(null);
                    },

                    toggleTesting() {
                        if (this.isRunning) {
                            this.stopTesting();
                        } else {
                            this.startTesting();
                        }
                    },

                    updatePopSpeed() {
                        if (this.isRunning && this.poppingInterval) {
                            clearInterval(this.poppingInterval);
                            this.poppingInterval = setInterval(() => this.playPulse(), this.popSpeed);
                        }
                        App.elements.popSpeedValue.textContent = `${this.popSpeed}ms`;
                        App.elements.popSpeedSlider.value = this.popSpeed;
                    },

                    updateGain() {
                        const gainPercent = Math.round(this.gain * 100);
                        App.elements.polarityGainValue.textContent = `${gainPercent}%`;
                        App.elements.polarityGainSlider.value = gainPercent;
                    },

                    handlePopSpeedChange() {
                        this.popSpeed = parseInt(App.elements.popSpeedSlider.value);
                        this.updatePopSpeed();
                    },

                    handleGainChange() {
                        this.gain = parseInt(App.elements.polarityGainSlider.value) / 100;
                        this.updateGain();
                    },

                    init() {
                        // Toggle switch
                        App.elements.polarityTestBtn.addEventListener('change', () => this.toggleTesting());
                        
                        // Pop speed slider
                        App.elements.popSpeedSlider.addEventListener('input', () => this.handlePopSpeedChange());
                        
                        // Gain slider
                        App.elements.polarityGainSlider.addEventListener('input', () => this.handleGainChange());
                        
                        // Initialize slider positions and values
                        this.updatePopSpeed();
                        this.updateGain();
                    }
                },

                // --- 8. File Analyzer Module ---
                fileAnalyzer: {
                    audioBuffer: null,
                    audioContext: null,

                    formatDuration(seconds) {
                        const mins = Math.floor(seconds / 60);
                        const secs = Math.floor(seconds % 60);
                        return `${mins}:${secs.toString().padStart(2, '0')}`;
                    },

                    calculateRMS(audioData) {
                        let sum = 0;
                        for (let i = 0; i < audioData.length; i++) {
                            sum += audioData[i] * audioData[i];
                        }
                        return Math.sqrt(sum / audioData.length);
                    },

                    calculatePeak(audioData) {
                        let peak = 0;
                        for (let i = 0; i < audioData.length; i++) {
                            const abs = Math.abs(audioData[i]);
                            if (abs > peak) peak = abs;
                        }
                        return peak;
                    },

                    calculateTHD(audioData, sampleRate) {
                        // Simple THD calculation - find fundamental and harmonics
                        const rms = this.calculateRMS(audioData);
                        const peak = this.calculatePeak(audioData);
                        
                        // Simple THD estimation based on signal characteristics
                        const crestFactor = peak / rms;
                        let thd = 0;
                        
                        if (crestFactor > 3) {
                            thd = 0.01; // Very clean signal
                        } else if (crestFactor > 2) {
                            thd = 0.1; // Good signal
                        } else {
                            thd = 1.0; // Distorted signal
                        }
                        
                        return thd;
                    },

                    detectClipping(audioData, threshold = 0.99) {
                        let clippedSamples = 0;
                        for (let i = 0; i < audioData.length; i++) {
                            if (Math.abs(audioData[i]) >= threshold) {
                                clippedSamples++;
                            }
                        }
                        return {
                            isClipped: clippedSamples > 0,
                            clippedSamples: clippedSamples,
                            clippingPercentage: (clippedSamples / audioData.length) * 100
                        };
                    },

                    analyzeAudioBuffer(buffer) {
                        console.log(`Analyzing audio buffer: ${buffer.length} samples, ${buffer.sampleRate}Hz, ${buffer.numberOfChannels} channels`);
                        
                        // Get the first channel for analysis
                        const audioData = buffer.getChannelData(0);
                        
                        // Calculate metrics
                        const peak = this.calculatePeak(audioData);
                        const rms = this.calculateRMS(audioData);
                        const thd = this.calculateTHD(audioData, buffer.sampleRate);
                        const clippingInfo = this.detectClipping(audioData);
                        
                        const peakDb = peak > 0 ? 20 * Math.log10(peak) : -Infinity;
                        const rmsDb = rms > 0 ? 20 * Math.log10(rms) : -Infinity;
                        
                        console.log(`Analysis results: Peak=${peakDb.toFixed(1)}dBFS, RMS=${rmsDb.toFixed(1)}dBFS, THD=${thd.toFixed(4)}%, Clipped=${clippingInfo.clippedSamples} samples`);
                        
                        // Update UI
                        App.elements.fileThdResult.textContent = `${thd.toFixed(4)}%`;
                        App.elements.filePeakLevel.textContent = `${peakDb.toFixed(1)} dBFS`;
                        App.elements.fileRmsLevel.textContent = `${rmsDb.toFixed(1)} dBFS`;
                        
                        // Update clipping status and show/hide de-clip controls
                        if (clippingInfo.isClipped) {
                            App.elements.fileClippingStatus.textContent = `${clippingInfo.clippedSamples} clips`;
                            App.elements.fileClippingStatus.className = 'text-xl font-semibold text-red-500 dark:text-red-400';
                            App.elements.declipControls.classList.remove('hidden');
                        } else {
                            App.elements.fileClippingStatus.textContent = 'OK';
                            App.elements.fileClippingStatus.className = 'text-xl font-semibold text-green-500 dark:text-green-400';
                            App.elements.declipControls.classList.add('hidden');
                        }
                        
                        // Color code THD result in the metrics grid
                        if (thd < 0.1) {
                            App.elements.fileThdResult.className = 'text-xl font-semibold text-green-500 dark:text-green-400';
                        } else if (thd < 1) {
                            App.elements.fileThdResult.className = 'text-xl font-semibold text-yellow-500 dark:text-yellow-400';
                        } else {
                            App.elements.fileThdResult.className = 'text-xl font-semibold text-red-500 dark:text-red-400';
                        }
                        
                        this.drawWaveform(audioData, clippingInfo);
                    },

                    drawWaveform(audioData, clippingInfo) {
                        const canvas = App.elements.fileWaveformCanvas;
                        const ctx = canvas.getContext('2d');
                        
                        // Set high-resolution canvas size
                        const rect = canvas.getBoundingClientRect();
                        const dpr = window.devicePixelRatio || 1;
                        
                        canvas.width = rect.width * dpr;
                        canvas.height = rect.height * dpr;
                        
                        // Scale the context to match device pixel ratio
                        ctx.scale(dpr, dpr);
                        
                        // Set canvas CSS size
                        canvas.style.width = rect.width + 'px';
                        canvas.style.height = rect.height + 'px';
                        
                        // Clear canvas with dark background
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        
                        // Calculate samples per pixel for better visualization
                        const canvasWidth = rect.width;
                        const canvasHeight = rect.height;
                        const samplesPerPixel = Math.floor(audioData.length / canvasWidth);
                        const centerY = canvasHeight / 2;
                        
                        // Draw waveform as vertical bars (like modern audio editors)
                        for (let x = 0; x < canvasWidth; x++) {
                            const startSample = x * samplesPerPixel;
                            const endSample = Math.min(startSample + samplesPerPixel, audioData.length);
                            
                            // Find min and max values in this pixel's sample range
                            let min = 0, max = 0;
                            let hasClipping = false;
                            
                            for (let i = startSample; i < endSample; i++) {
                                const sample = audioData[i];
                                if (sample > max) max = sample;
                                if (sample < min) min = sample;
                                
                                // Check for clipping in this range
                                if (Math.abs(sample) >= 0.99) {
                                    hasClipping = true;
                                }
                            }
                            
                            // Convert to pixel coordinates
                            const maxY = centerY - (max * centerY * 0.9);
                            const minY = centerY - (min * centerY * 0.9);
                            
                            // Choose color based on clipping
                            if (hasClipping) {
                                ctx.fillStyle = '#ef4444'; // Red for clipped samples
                            } else {
                                // Blue gradient based on amplitude
                                const amplitude = Math.max(Math.abs(max), Math.abs(min));
                                const intensity = Math.min(amplitude * 2, 1);
                                const blue = Math.floor(59 + (196 * intensity)); // From dark blue to bright blue
                                ctx.fillStyle = `rgb(59, 130, ${blue})`;
                            }
                            
                            // Draw vertical bar
                            const barHeight = Math.max(1, minY - maxY);
                            ctx.fillRect(x, maxY, 1, barHeight);
                        }
                        
                        // Draw center line
                        ctx.strokeStyle = '#374151';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([2, 2]);
                        ctx.beginPath();
                        ctx.moveTo(0, centerY);
                        ctx.lineTo(canvasWidth, centerY);
                        ctx.stroke();
                        ctx.setLineDash([]);
                        
                        console.log('Professional waveform drawn with clipping detection');
                    },

                    // De-clipping algorithm using cubic spline interpolation
                    deClipAudio(audioData, threshold = 0.99) {
                        console.log('Starting de-clipping process...');
                        const deClippedData = new Float32Array(audioData.length);
                        
                        // Copy original data
                        for (let i = 0; i < audioData.length; i++) {
                            deClippedData[i] = audioData[i];
                        }
                        
                        // Find clipped regions
                        const clippedRegions = [];
                        let inClippedRegion = false;
                        let regionStart = -1;
                        
                        for (let i = 0; i < audioData.length; i++) {
                            const isClipped = Math.abs(audioData[i]) >= threshold;
                            
                            if (isClipped && !inClippedRegion) {
                                // Start of clipped region
                                regionStart = i;
                                inClippedRegion = true;
                            } else if (!isClipped && inClippedRegion) {
                                // End of clipped region
                                clippedRegions.push({ start: regionStart, end: i - 1 });
                                inClippedRegion = false;
                            }
                        }
                        
                        // Handle case where file ends in clipped region
                        if (inClippedRegion) {
                            clippedRegions.push({ start: regionStart, end: audioData.length - 1 });
                        }
                        
                        console.log(`Found ${clippedRegions.length} clipped regions`);
                        
                        // Process each clipped region
                        clippedRegions.forEach((region, index) => {
                            const { start, end } = region;
                            const regionLength = end - start + 1;
                            
                            // Get context samples before and after the clipped region
                            const contextSize = Math.min(10, Math.floor(regionLength / 2));
                            const preStart = Math.max(0, start - contextSize);
                            const postEnd = Math.min(audioData.length - 1, end + contextSize);
                            
                            // Use cubic spline interpolation to reconstruct the clipped region
                            this.cubicSplineInterpolation(deClippedData, preStart, start, end, postEnd);
                            
                            console.log(`Processed clipped region ${index + 1}: samples ${start}-${end}`);
                        });
                        
                        console.log('De-clipping process completed');
                        return deClippedData;
                    },

                    // Cubic spline interpolation for smooth reconstruction
                    cubicSplineInterpolation(data, preStart, clipStart, clipEnd, postEnd) {
                        // Get the boundary values and their positions
                        const x0 = preStart;
                        const x1 = clipStart - 1;
                        const x2 = clipEnd + 1;
                        const x3 = postEnd;
                        
                        const y0 = data[x0] || 0;
                        const y1 = data[x1] || 0;
                        const y2 = data[x2] || 0;
                        const y3 = data[x3] || 0;
                        
                        // Calculate derivatives at the boundaries
                        const d1 = (y2 - y1) / (x2 - x1);
                        const d2 = (y3 - y0) / (x3 - x0);
                        
                        // Interpolate each sample in the clipped region
                        for (let i = clipStart; i <= clipEnd; i++) {
                            const t = (i - x1) / (x2 - x1); // Normalize to [0, 1]
                            
                            // Cubic Hermite interpolation
                            const t2 = t * t;
                            const t3 = t2 * t;
                            
                            const h00 = 2 * t3 - 3 * t2 + 1;
                            const h10 = t3 - 2 * t2 + t;
                            const h01 = -2 * t3 + 3 * t2;
                            const h11 = t3 - t2;
                            
                            const interpolatedValue = h00 * y1 + h10 * d1 * (x2 - x1) + h01 * y2 + h11 * d2 * (x2 - x1);
                            
                            // Apply some smoothing and ensure we don't exceed the threshold
                            data[i] = Math.max(-0.95, Math.min(0.95, interpolatedValue));
                        }
                    },

                    async downloadDeClippedAudio() {
                        if (!this.audioBuffer) {
                            alert('No audio file loaded');
                            return;
                        }
                        
                        const btn = App.elements.declipDownloadBtn;
                        const originalText = btn.textContent;
                        btn.disabled = true;
                        btn.innerHTML = '<svg class="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span class="ml-2">De-clipping...</span>';
                        
                        try {
                            // Create offline context for processing
                            const sampleRate = this.audioBuffer.sampleRate;
                            const duration = this.audioBuffer.duration;
                            const offlineCtx = new OfflineAudioContext(this.audioBuffer.numberOfChannels, sampleRate * duration, sampleRate);
                            
                            // Process each channel
                            const processedBuffer = offlineCtx.createBuffer(
                                this.audioBuffer.numberOfChannels,
                                this.audioBuffer.length,
                                sampleRate
                            );
                            
                            for (let channel = 0; channel < this.audioBuffer.numberOfChannels; channel++) {
                                const originalData = this.audioBuffer.getChannelData(channel);
                                const deClippedData = this.deClipAudio(originalData);
                                processedBuffer.copyToChannel(deClippedData, channel);
                            }
                            
                            // Convert to WAV and download
                            const wavBuffer = App.audio.bufferToWav(processedBuffer);
                            const blob = new Blob([wavBuffer], { type: 'audio/wav' });
                            const filename = `declipped_${Date.now()}.wav`;
                            
                            App.audio.downloadFile(blob, filename);
                            
                            console.log('De-clipped audio downloaded successfully');
                            
                        } catch (error) {
                            console.error('Error during de-clipping:', error);
                            alert('Error processing audio: ' + error.message);
                        } finally {
                            btn.disabled = false;
                            btn.innerHTML = originalText;
                        }
                    },

                    async processFile(file) {
                        console.log(`Processing file: ${file.name} (${(file.size / 1024 / 1024).toFixed(1)} MB)`);
                        
                        try {
                            // Create audio context if needed
                            if (!this.audioContext) {
                                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            }
                            
                            // Read file as array buffer
                            const arrayBuffer = await file.arrayBuffer();
                            console.log('File read as ArrayBuffer');
                            
                            // Decode audio data
                            this.audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                            console.log('Audio file decoded successfully');
                            
                            // Update file info
                            App.elements.fileName.textContent = file.name;
                            App.elements.fileDuration.textContent = this.formatDuration(this.audioBuffer.duration);
                            App.elements.fileSampleRate.textContent = `${this.audioBuffer.sampleRate} Hz`;
                            App.elements.fileChannels.textContent = this.audioBuffer.numberOfChannels;
                            
                            // Show file info, analysis metrics, waveform, and action buttons; hide main drop area
                            App.elements.fileInfo.classList.remove('hidden');
                            document.getElementById('file-analysis-metrics').classList.remove('hidden');
                            App.elements.fileDropArea.classList.add('hidden');
                            App.elements.fileAnalysis.classList.remove('hidden');
                            App.elements.fileActions.classList.remove('hidden');
                            
                            // Analyze the audio
                            this.analyzeAudioBuffer(this.audioBuffer);
                            
                        } catch (error) {
                            console.error(`Failed to process file: ${error.message}`);
                            alert(`Error processing file: ${error.message}`);
                        }
                    },

                    setupDragAndDrop() {
                        const dropArea = App.elements.fileDropArea;
                        const fileInput = App.elements.fileInput;
                        
                        // Function to setup drag and drop for a drop zone
                        const setupDropZone = (dropZone, inputElement) => {
                            // Handle drag events
                            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                                dropZone.addEventListener(eventName, this.preventDefaults, false);
                            });
                            
                            // Highlight drop area when dragging over it
                            ['dragenter', 'dragover'].forEach(eventName => {
                                dropZone.addEventListener(eventName, () => {
                                    dropZone.classList.add('border-blue-500', 'bg-blue-500/10');
                                });
                            });
                            
                            ['dragleave', 'drop'].forEach(eventName => {
                                dropZone.addEventListener(eventName, () => {
                                    dropZone.classList.remove('border-blue-500', 'bg-blue-500/10');
                                });
                            });
                            
                            // Handle dropped files
                            dropZone.addEventListener('drop', (e) => {
                                const files = e.dataTransfer.files;
                                if (files.length > 0) {
                                    this.processFile(files[0]);
                                }
                            });
                            
                            // Handle click to select file
                            dropZone.addEventListener('click', () => {
                                inputElement.click();
                            });
                            
                            // Handle file input change
                            inputElement.addEventListener('change', (e) => {
                                if (e.target.files.length > 0) {
                                    this.processFile(e.target.files[0]);
                                }
                            });
                        };
                        
                        // Setup main drop area
                        setupDropZone(dropArea, fileInput);
                        
                        // Setup load new file button
                        const loadNewFileBtn = document.getElementById('load-new-file-btn');
                        const fileInputButton = document.getElementById('file-input-button');
                        if (loadNewFileBtn && fileInputButton) {
                            loadNewFileBtn.addEventListener('click', () => {
                                fileInputButton.click();
                            });
                            
                            fileInputButton.addEventListener('change', (e) => {
                                if (e.target.files.length > 0) {
                                    this.processFile(e.target.files[0]);
                                }
                            });
                        }
                        
                        // Setup de-clip download button
                        const declipBtn = App.elements.declipDownloadBtn;
                        if (declipBtn) {
                            declipBtn.addEventListener('click', () => {
                                this.downloadDeClippedAudio();
                            });
                        }
                    },

                    preventDefaults(e) {
                        e.preventDefault();
                        e.stopPropagation();
                    },

                    init() {
                        this.setupDragAndDrop();
                        console.log('File analyzer initialized');
                    }
                },

                // --- 9. Audio Output Module ---
                audioOutput: {
                    availableDevices: [],
                    currentDevice: null,
                    
                    async enumerateDevices() {
                        try {
                            const devices = await navigator.mediaDevices.enumerateDevices();
                            this.availableDevices = devices.filter(device => device.kind === 'audiooutput');
                            this.updateDeviceList();
                        } catch (error) {
                            console.error('Error enumerating audio devices:', error);
                        }
                    },
                    
                    updateDeviceList() {
                        const select = App.elements.outputDeviceSelect;
                        if (!select) return;
                        
                        // Clear existing options except default
                        select.innerHTML = '<option value="default">Default Audio Device</option>';
                        
                        // Add available devices
                        this.availableDevices.forEach(device => {
                            const option = document.createElement('option');
                            option.value = device.deviceId;
                            option.textContent = device.label || `Audio Device ${device.deviceId.slice(0, 8)}`;
                            select.appendChild(option);
                        });
                    },
                    
                    updateDevice() {
                        const deviceId = App.elements.outputDeviceSelect.value;
                        this.currentDevice = deviceId === 'default' ? null : deviceId;
                        console.log('Audio output device changed to:', this.currentDevice || 'default');
                    },
                    
                    updateStatus() {
                        const state = App.elements.audioContextState;
                        const sampleRate = App.elements.audioContextSamplerate;
                        
                        if (App.state.audioContext) {
                            state.textContent = App.state.audioContext.state;
                            sampleRate.textContent = App.state.audioContext.sampleRate;
                        } else {
                            state.textContent = 'Not initialized';
                            sampleRate.textContent = '--';
                        }
                    },
                    
                    async testAudio() {
                        const button = App.elements.testAudioButton;
                        const originalText = button.innerHTML;
                        
                        try {
                            button.disabled = true;
                            button.innerHTML = '<svg class="w-4 h-4 animate-spin" fill="none" viewBox="0 0 24 24"><circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle><path class="opacity-75" fill="currentColor" d="m4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path></svg><span class="ml-2">Testing...</span>';
                            
                            // Create a temporary audio context for testing
                            const testContext = new (window.AudioContext || window.webkitAudioContext)();
                            const oscillator = testContext.createOscillator();
                            const gainNode = testContext.createGain();
                            
                            oscillator.connect(gainNode);
                            gainNode.connect(testContext.destination);
                            
                            oscillator.frequency.value = 440; // A4 note
                            gainNode.gain.value = 0.1; // Low volume
                            
                            oscillator.start();
                            
                            // Play for 500ms
                            setTimeout(() => {
                                oscillator.stop();
                                testContext.close();
                                button.disabled = false;
                                button.innerHTML = originalText;
                            }, 500);
                            
                        } catch (error) {
                            console.error('Error testing audio:', error);
                            button.disabled = false;
                            button.innerHTML = originalText;
                        }
                    }
                }
            };

            // --- Start the application ---
            App.init();
            App.polarityChecker.init();
            App.fileAnalyzer.init();
        });
    </script>

</body>
</html>
